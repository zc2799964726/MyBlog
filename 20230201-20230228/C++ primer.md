#### 2.1 基本内置类型

切勿混用带符号类型和无符号类型

指定字面值的类型

表2.2中所列的前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。

布尔字面值和指针字面值

nullptr是指针字面值

#### 2.2 变量

对象是指一块能存储数据并具有某种类型的内存空间

初始值当对象在创建时获得了一个特定的值，我们说这个对象被初始化（initialized

在C++语言中，初始化是一个异常复杂的问题，我们也将反复讨论这个问题。很多程序员对于用等号=来初始化变量的方式倍感困惑，这种方式容易让人认为初始化是赋值的一种。事实上在C++语言中，初始化和赋值是两个完全不同的操作。

> 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。

==初始化和赋值的区别:
创建时赋予一个初值
吧当前对象的值擦除，用新的值代替==

> 列表初始化

==花括号==

在，无论是初始化对象还是某些时候为对象赋新值，都可以使用这样一组由花括号括起来的初始值了。

如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错：

刚刚所介绍的看起来无关紧要，毕竟我们不会故意用long double的值去初始化int变量。然而，像第16章介绍的一样，这种初始化有可能在不经意间发生。

定义在函数体内部的内置类型变量将不被初始化

每个类各自决定其初始化对象的方式

定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有显式地初始化，则其值由类确定

声明（declaration）使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义（definition）负责创建与名字关联的实体。

在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误

如果要在多个文件中使用同一个变量，就必须将声明和定义分离

#### 2.3 复合类型

复合类型（compound type）是指基于其他类型定义的类型。C++语言有几种复合类型，本章将介绍其中的两种：引用和指针。

引用（reference）为对象起了另外一个名字，引用类型引用（refers to）另外一种类型。通过将声明符写成&d的形式来定义引用类型，其中d是声明的变量名

因为无法令引用重新绑定到另外一个对象，因此引用必须初始化

引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。

将要介绍的两种例外情况，其他所有引用的类型都要和与之绑定的对象严格匹配

指针（pointer）是“指向（point to）”另外一种类型的复合类型

针也实现了对其他对象的间接访问

指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象

指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

> 获取对象的地址指针存放某个对象的地址，要想获取该地址，需要使用取地址符（操作符&）：

==打印用%p==

> 获取对象的地址指针存放某个对象的地址，要想获取该地址，需要使用取地址符（操作符&）：

==想要打印某一个变量的地址，用取地址符&，取了之后可以直接赋给指针或者打印==

> 将要介绍的两种例外情况，其他所有指针的类型都要和它所指向的对象严格匹配：

==第一种：令指向常量的指针去指向一个非常量对象 *const==

> 因为在声明语句中指针的类型实际上被用于指定它所指向对象的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。

==这句话也就是为什么对指针这个对象进行解引用或者其他操作的时候，不会发生错误
指针本身也是一个对象(2.4.3第一句话)==

指针值

1.指向一个对象。2.指向紧邻对象所占空间的下一个位置。3.空指针，意味着指针没有指向任何对象。4.无效指针，也就是上述情况之外的其他值

> 利用指针访问对象

==访问操作==

对指针解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值

解引用操作仅适用于那些确实指向了某个对象的有效指针。

关键概念：某些符号有多重含义

空指针（null pointer）不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。以下列出几个生成空指针的方法

当用到一个预处理变量时，预处理器会自动地将它替换为实际值

建议：初始化所有指针

尽量等定义了对象之后再定义指向它的指针

这样程序就能检测并知道它没有指向任何具体的对象了。

赋值和指针

其中最重要的一点就是引用本身并非一个对象

任何非0指针对应的条件值都是true

不同的是，我们对该地址中到底是个什么类型的对象并不了解：

拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个void＊指针。不能直接操作void＊指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。

这种形式着重强调变量具有的复合类型。第二种把修饰符和类型名写在一起，并且每条语句只定义一个变量：

这种形式着重强调本次声明定义了一种复合类型

上述两种定义指针或引用的不同方法没有孰对孰错之分，关键是选择并坚持其中的一种写法，不要总是变来变去。

本书采用第一种写法，将＊（或是&）与变量名连在一起

指向指针的指针

指向指针的引用

> 用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用：

==有点难==

> 要理解r的类型到底是什么，最简单的办法是从右向左阅读r的定义

==从右往左读类型！！！！！！！！！！！！！！！！！！==

面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义。

#### 2.4 const限定符

> 正如之前反复提到的，对象的类型决定了其上的操作

==真的是反复提到，知道类型了才能进行操作==

在不改变const对象的操作中还有一种是初始化，如果利用一个对象去初始化另外一个对象，则它们是不是const都无关紧要：

默认状态下，const对象仅在文件内有效

编译器将在编译过程中把用到该变量的地方都替换成对应的值。也就是说，编译器会找到代码中所有用到bufSize的地方，然后用512替换。

对于const变量不管是声明还是定义都添加extern关键字，这样只需定义一次就可以了：

如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。

最简单的办法是弄清楚当一个常量引用被绑定到另外一种类型上时到底发生了什么：

ri绑定了一个临时量（temporary）对象。所谓临时量对象就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。C++程序员们常常把临时量对象简称为临时量。

试试这样想吧：所谓指向常量的指针或引用，不过是指针或引用“自以为是”罢了，它们觉得自己指向了常量，所以自觉地不去改变所指对象的值。

＊放在const关键字之前用以说明指针是一个常量

用名词顶层const（top-level const）表示指针本身是个常量

层const（low-level const）表示指针所指的对象是一个常量。

值不会改变并且在编译过程就能得到计算结果的表达式

允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式

算术类型、引用和指针都属于字面值类型

尽管指针和引用都能定义成constexpr，但它们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。

#### 2.5 处理类型

类型别名（type alias）是一个名字，它是某种类型的同义词。使用类型别名有很多好处，它让复杂的类型名字变得简单明了、易于理解和使用，还有助于程序员清楚地知道使用该类型的真实目的。

有两种方法可用于定义类型别名。传统的方法是使用关键字typedef：

新标准规定了一种新的方法，使用别名声明（alias declaration）来定义类型的别名：

指针、常量和类型别名

遇到一条使用了类型别名的声明语句时，人们往往会错误地尝试把类型别名替换成它本来的样子，以理解该语句的含义：

其基本数据类型是指针

可是用char＊重写了声明语句后，数据类型就变成了char，＊成为了声明符的一部分。这样改写的结果是，const char成了基本数据类型。前后两种声明含义截然不同，前者声明了一个指向char的常量指针，改写后的形式则声明了一个指向const char的指针。

#### 2.6 自定义数据结构

很多新手程序员经常忘了在类定义的最后加上分号。

C++11新标准规定，可以为数据成员提供一个类内初始值（in-class initializer）。

一次是直接包含的，另有一次是随着包含Sales_data.h被隐式地包含进来的。有必要在书写头文件时做适当处理，使其遇到多次包含的情况也能安全和正常地工作。

预处理器概述

仍能安全工作的常用技术是预处理器（preprocessor）

#ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到#endif指令为止。

> 整个程序中的预处理变量包括头文件保护符必须唯一，通常的做法是基于头文件中类的名字来构建保护符的名字，以确保其唯一性。为了避免与程序中的其他实体发生名字冲突，一般把预处理变量的名字全部大写

==头文件保护==

头文件即使（目前还）没有被包含在任何其他头文件中，也应该设置保护符。头文件保护符很简单，程序员只要习惯性地加上就可以了，没必要太在乎你的程序到底需不需要。

#### 3.1 命名空间的using声明

头文件不应包含using声明

#### 3.2 标准库类型string

C++标准一方面对库类型所提供的操作做了详细规定，另一方面也对库的实现者做出一些性能上的需求。因此，标准库类型对于一般应用场合来说有足够的效率。

读取未知数量的string对象

使用getline读取一整行

string：：size_type类型

这些配套类型体现了标准库类型与机器无关的特性，类型size_type即是其中的一种

它是一个无符号类型的值（参见2.1.1节，第30页）而且能足够存放下任何string对象的大小。所有用于存放string类的size函数返回值的变量，都应该是string：：size_type类型的。

因为负值n会自动地转换成一个比较大的无符号值。

如果一条表达式中已经有了size（）函数就不要再使用int了，这样可以避免混用int和unsigned可能带来的问题

1.如果两个string对象的长度不同，而且较短string对象的每个字符都与较长string对象对应位置上的字符相同，就说较短string对象小于较长string对象。2.如果两个string对象在某些对应的位置上不一致，则string对象比较的结果其实是string对象中第一对相异字符比较的结果。

当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符（+）的两侧的运算对象至少有一个是string：

因为某些历史原因，也为了与C兼容，所以C++语言中的字符串字面值并不是标准库类型string的对象。切记，字符串字面值与string是不同的类型。

在cctype头文件中定义了一组标准库函数处理这部分工作

建议：使用C++版本的C标准库头文件

C++则将这些文件命名为cname

改变string对象中字符的值，必须把循环变量定义成引用类型

> 例如，想要编写一个程序把0到15之间的十进制数转换成对应的十六进制形式，只需初始化一个字符串令其存放16个十六进制“数字”：

==十进制十六进制==

#### 3.3 标准库类型vector

vector是一个类模板

编译器根据模板创建类或函数的过程称为实例化（instantiation）

类或函数实例化成何种类型

要使用size_type，需首先指定它是由哪种类型定义的。vector对象的类型总是包含着元素的类型（参见3.3节，第87页）：

#### 3.4 迭代器介绍

严格来说，string对象不属于容器类型，但是string支持很多与容器类型类似的操作

如果容器为空，则begin和end返回的是同一个迭代器，都是尾后迭代器。

和指针类似，也能通过解引用迭代器来获取它所指示的元素，执行解引用的迭代器必须合法并确实指示着某个元素（参见2.3.2节，第48页）

迭代器使用递增（++）运算符（参见1.4.1节，第11页）来从一个元素移动到下一个元素。

因为end返回的迭代器并不实际指示某个元素，所以不能对其进行递增或解引用的操作。

> C++程序员习惯性地使用！=，其原因和他们更愿意使用迭代器而非下标的原因一样：因为这种编程风格在标准库提供的所有容器上都有效。

==很重要！不等号在所有容器上均生效==

所有标准库容器的迭代器都定义了==和！=，但是它们中的大多数都没有定义<运算符

#### 3.5 数组

默认情况下，类型修饰符从右向左依次绑定。对于ptrs来说，从右向左（参见2.3.3节，第52页）理解其含义比较简单：

> 所以就数组而言，由内向外阅读要比从右向左好多了。由内向外的顺序可帮助我们更好地理解Parray的含义：首先是圆括号括起来的部分，＊Parray意味着Parray是个指针，接下来观察右边，可知道Parray是个指向大小为10的数组的指针，最后观察左边，知道数组中的元素是int。这样最终的含义就明白无误了，Parray是一个指针，它指向一个int数组，数组中包含10个元素。同理，（&arrRef）表示arrRef是一个引用，它引用的对象是一个大小为10的数组，数组中元素的类型是int。

==明白数组怎么阅读==

要想理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读。

> 在C++语言中，指针和数组有非常紧密的联系。就如即将介绍的，使用数组的时候编译器一般会把它转换成指针。

==使用数组时，编译器会把它转换成指针==

在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针。

其中一层意思是当使用数组作为一个auto（参见2.5.2节，第61页）变量的初始值时，推断得到的类型是指针而非数组：

必须指出的是，当使用decltype关键字（参见2.5.3节，第62页）时上述转换不会发生，decltype（ia）返回的类型是由10个整数构成的数组

指针也是迭代器

不过获取尾后指针就要用到数组的另外一个特殊性质了。我们可以设法获取数组尾元素之后的那个并不存在的元素的地址：

。正确的使用形式是将数组作为它们的参数：

begin函数返回指向ia首元素的指针，end函数返回指向ia尾元素下一位置的指针，这两个函数定义在iterator头文件中。

ip加上4所得的结果仍是一个指针，该指针所指的元素与ip原来所指的元素相比前进了4个位置。

两个指针相减的结果的类型是一种名为ptrdiff_t的标准库类型，和size_t一样，ptrdiff_t也是一种定义在cstddef头文件中的机器相关的类型。因为差值可能为负值，所以ptrdiff_t是一种带符号类型。

上述指针运算同样适用于空指针（参见2.3.2节，第48页）和所指对象并非数组的指针

解引用和指针运算的交互

指针加上一个整数所得的结果还是一个指针

一个典型的例子是当对数组使用下标运算符时，编译器会自动执行上述转换操作

内置的下标运算符所用的索引值不是无符号类型，这一点与vector和string不一样。

传入此类函数的指针必须指向以空字符作为结束的数组：

如果把这些运算符用在两个C风格字符串上，实际比较的将是指针而非字符串本身：

同样的操作如果放到ca1和ca2这两个数组身上就会产生错误了。表达式ca1 + ca2试图将两个指针相加，显然这样的操作没什么意义，也肯定是非法的。

对大多数应用来说，使用标准库string要比使用C风格字符串更安全、更高效。

与旧代码的接口

 允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值

string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）；在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。

顾名思义，c_str函数的返回值是一个C风格的字符串。也就是说，函数的返回结果是一个指针，该指针指向一个以空字符结束的字符数组，而这个数组所存的数据恰好与那个string对象的一样。结果指针的类型是const char＊，从而确保我们不会改变字符数组的内容。

如果执行完c_str（）函数后程序想一直都能使用其返回的数组，最好将该数组重新拷贝一份。

> 使用数组初始化vector对象

==很实用==

现代的C++程序应当尽量使用vector和迭代器，避免使用内置数组和指针；应该尽量使用string，避免使用C风格的基于数组的字符串。

#### 3.6 多维数组

严格来说，C++语言中没有多维数组，通常所说的多维数组其实是数组的数组。谨记这一点，对今后理解和使用多维数组大有益处。

允许使用花括号括起来的一组值初始化多维数组，这点和普通的数组一样

其中内层嵌套着的花括号并非必需的，

如果表达式含有的下标运算符数量和数组的维度一样多，该表达式的结果将是给定类型的元素；反之

如果表达式含有的下标运算符数量比数组的维度小，则表达式的结果将是给定索引处的一个内层数组

范围for语句

以我们选用引用类型作为循环控制变量，但其实还有一个深层次的原因促使我们这么做

假设不用引用类型，则循环如下述形式：

程序将无法通过编译

要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。

当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针。

在上述声明中，圆括号必不可少

#### 术语表

difference_type由string和vector定义的一种带符号整数类型，表示两个迭代器之间的距离。

getline 在string头文件中定义的一个函数，以一个istream对象和一个string对象为输入参数。该函数首先读取输入流的内容直到遇到换行符停止，然后将读入的数据存入string对象，最后返回istream对象。其中换行符读入但是不保留

prtdiff_t 是cstddef头文件中定义的一种与机器实现有关的带符号整数类型，它的空间足够大，能够表示数组中任意两个指针之间的距离。

[ ]运算符（[ ] operator）下标运算符。

>>运算符（>>operator）标准库类型string定义的输入运算符，负责读入一组字符，遇到空白停止

### 第4章 表达式

表达式由一个或多个运算对象（operand）组成，对表达式求值将得到一个结果（result）。字面值和变量是最简单的表达式（expression）

#### 4.1 基础

函数调用也是一种特殊的运算符，它对运算对象的数量没有限制。

只要它们能被转换（参见2.1.2节，第32页）成同一种类型即可。

#### 4.6 成员访问运算符

点运算符（参见1.5.2节，第21页）和箭头运算符（参见3.4.1节，第98页）都可用于访问成员，其中，点运算符获取类对象的一个成员；箭头运算符与点运算符有关，表达式ptr->mem等价于（*ptr）.mem：

#### 4.11 类型转换

果某个运算对象的类型是无符号类型，那么转换的结果就要依赖于机器中各个整数类型的相对大小了

数组转换成指针：在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针：

数组被用作decltype关键字的参数，或者作为取地址符（&）、sizeof及typeid（第19.2.2节，732页将介绍）等运算符的运算对象时，上述转换不会发生

包括常量整数值0或者字面值nullptr能转换成任意指针类型；指向任意非常量的指针能转换成void＊

对象的指针能转换成const void＊

转换成布尔类型：

：允许将指向非常量类型的指针转换成指向相应的常量类型的指针，对于引用也是这样

类类型定义的转换：类类型能定义由编译器自动执行的转换，不过编译器每次只能执行一种类类型的转换。在7.5.4节（第263页）中我们将看到一个例子，如果同时提出多个转换请求，这些请求将被拒绝。

条件（cin>>s）读入cin的内容并将cin作为其求值结果。条件部分本来需要一个布尔类型的值，但是这里实际检查的是istream类型的值。幸好，IO库定义了从istream向布尔值转换的规则，根据这一规则，cin自动地转换成布尔值

type是转换的目标类型而expression是要转换的值。如果type是引用类型，则结果是左值。

cast-name是static_cast、dynamic_cast、const_cast和reinterpret_cast中的一种

任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。

当需要把一个较大的算术类型赋值给较小的类型时，static_cast非常有用

static_cast对于编译器无法自动执行的类型转换也非常有用。例如，我们可以使用static_cast找回存在于void＊指针（参见2.3.2节，第50页）中的值

当我们把指针存放在void＊中，并且使用static_cast将其强制转换回原来的类型时，应该确保指针的值保持不变。也就是说，强制转换的结果将与原始的地址值相等，因此我们必须确保转换后所得的类型就是指针所指的类型。

对于将常量对象转换成非常量对象的行为，我们一般称其为“去掉const性质（cast away the const）”

只有const_cast能改变表达式的常量属性，使用其他形式的命名强制类型转换改变表达式的常量属性都将引发编译器错误

const_cast常常用于有函数重载的上下文中，关于函数重载将在6.4节（第208页）进行详细介绍。

reinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释

其中的关键问题是类型改变了，但编译器没有给出任何警告或者错误的提示信息

#### 5.1 简单语句

末尾加上分号就变成了表达式语句

复合语句（compound statement）是指用花括号括起来的（可能为空的）语句和声明的序列，复合语句也被称作块（block）。

个块就是一个作用域

#### 5.2 语句作用域

因为控制结构定义的对象的值马上要由结构本身使用，所以这些变量必须初始化。

#### 5.3 条件语句

一般不要省略case分支最后的break语句。如果没写break语句，最好加一段注释说清楚程序的逻辑

#### 5.6 try语句块和异常处理

throw表达式（throw expression），异常检测部分使用throw表达式来表示它遇到了无法处理的问题。我们说throw引发（raise）了异常。

并以一个或多个catch子句（catch clause）结束

类型runtime_error是标准库异常类型的一种，定义在stdexcept头文件中

编写异常安全的代码非常困难

exception头文件定义了最通用的异常类exception。它只报告异常的发生，不提供任何额外信息

stdexcept头文件定义了几种常用的异常类，详细信息在表5.1中列出。

new头文件定义了bad_alloc异常类型，这种类型将在12.1.2节（第407页）详细介绍

type_info头文件定义了bad_cast异常类型，这种类型将在19.2节（第731页）详细介绍

我们只能以默认初始化（参见2.2.1节，第40页）的方式初始化exception、bad_alloc和bad_cast对象，不允许为这些对象提供初始值。

#### 6.1 函数基础

一是用实参初始化函数对应的形参

此时，主调函数（calling function）的执行被暂时中断，被调函数（called function）开始执行。

> 执行函数的第一步是（隐式地）定义并初始化它的形参

==但是非常不建议！！==

> 执行函数的第一步是（隐式地）定义并初始化它的形参

==只要有形参类型，而不需要有形参名字==

> 执行函数的第一步是（隐式地）定义并初始化它的形参

==函数申明其实可以不用写形参，函数定义时写上即可，不知道 在哪里看过==

函数的返回类型不能是数组（参见3.5节，第101页）类型或函数类型，但可以是指向数组或函数的指针

在6.7节（第221页）将介绍如何返回指向函数的指针。

我们把只存在于块执行期间的对象称为自动对象（automatic object）

局部静态对象（local static object）在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。

函数的声明和函数的定义非常类似，唯一的区别是函数声明无须函数体，用一个分号替代即可。

函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了调用该函数所需的全部信息。函数声明也称作函数原型（function prototype）。

，C++语言支持所谓的分离式编译（separate compilation）

要生成可执行文件（executable file），必须告诉编译器我们用到的代码在哪里。对于上述几个文件来说，编译的过程如下所示：

这一过程通常会产生一个后缀名是.obj（Windows）或.o（UNIX）的文件

#### 6.2 参数传递

形参初始化的机理与变量初始化一样。

引用形参是它对应的实参的别名

当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。我们说这样的实参被值传递（passed by value）或者函数被传值调用（called by value）。

指针的行为和其他非引用类型一样。当执行指针拷贝操作时，拷贝的是指针的值

熟悉C的程序员常常使用指针类型的形参访问函数外部的对象。在C++语言中，建议使用引用类型的形参替代指针

拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型（包括IO类型在内）根本就不支持拷贝操作

某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象

如果函数无须改变引用形参的值，最好将其声明为常量引用。

使用引用形参返回额外信息

一种方法是定义一个新的数据类型，让它包含位置和数量两个成员。还有另一种更简单的方法，我们可以给函数传入一个额外的引用实参，令其保存字符出现的次数：

当用实参初始化形参时会忽略掉顶层const。换句话说，形参的顶层const被忽略掉了

const int＊

。当编译器处理对print函数的调用时，只检查传入的参数是否是const int＊类型

因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外的信息。管理指针形参有三种常用的技术。

使用标记指定数组长度

使用标准库规范

显式传递一个表示数组大小的形参

&arr两端的括号必不可少（参见3.5.1节，第101页）：

我们曾经介绍过，在C++语言中实际上没有真正的多维数组（参见3.6节，第112页），所谓多维数组其实是数组的数组。

再一次强调，＊matrix两端的括号必不可少：

当使用argv中的实参时，一定要记得可选的实参从argv[1]开始；argv[0]保存程序的名字，而非用户输入。

为了编写能处理不同数量实参的函数，C++11新标准提供了两种主要的方法：如果所有的实参类型相同，可以传递一个名为initializer_list的标准库类型

我们可以编写一种特殊的函数，也就是所谓的可变参数模板

initializer_list形参

#### 6.3 返回类型和return语句

return语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。

值是如何被返回的

该函数将返回word的副本或者一个未命名的临时string对象，该对象的内容是word和ending的和。

不要返回局部对象的引用或指针

返回类类型的函数和调用运算符

调用运算符的优先级与点运算符和箭头运算符（参见4.6节，第133页）相同，并且也符合左结合律

引用返回左值

函数的返回类型决定函数调用是否是左值（参见4.1.1节，第121页）。调用一个返回引用的函数得到左值，其他返回类型得到右值。

列表初始化返回值

如果函数返回的是内置类型，则花括号包围的列表最多包含一个值，而且该值所占空间不应该大于目标类型的空间（参见2.2.1节，第39页）。如果函数返回的是类类型，由类本身定义初始值如何使用（参见3.3.1节，第89页）。

cstdlib头文件定义了两个预处理变量

递归如果一个函数调用了它自身，不管这种调用是直接的还是间接的，都称该函数为递归函数（recursive function）

在递归函数中，一定有某条路径是不包含递归调用的；否则，函数将“永远”递归下去，换句话说，函数将不断地调用它自身直到程序栈空间耗尽为止

main函数不能调用它自己。

因为数组不能被拷贝，所以函数不能返回数组。

函数可以返回数组的指针或引用（参见3.5.1节，第102页）

其中最直接的方法是使用类型别名（参见2.5.1节，第60页）

和这些声明一样，如果我们想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。然而，函数的形参列表也跟在函数名字后面且形参列表应该先于数组的维度。因此，返回数组指针的函数形式如下所示：

使用尾置返回类型

使用decltype

#### 6.4 函数重载

main函数不能重载

顶层const（参见2.4.3节，第57页）不影响传入函数的对象。

另一方面，如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的：

当我们传递一个非常量对象或者指向非常量对象的指针时，编译器会优先选用非常量版本的函数。

因此我们需要一种新的shorterString函数，当它的实参不是常量时，得到的结果是一个普通的引用，使用const_cast可以做到这一点：

编译器找到一个与实参最佳匹配（best match）的函数，并生成调用该函数的代码。

在C++语言中，名字查找发生在类型检查之前。

#### 6.5 特殊用途语言特性

默认实参负责填补函数调用缺少的尾部实参（靠右侧位置）

内联函数可避免函数调用的开销

内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求。

constexpr函数（constexpr function）是指能用于常量表达式（参见2.4.4节，第58页）的函数

我们允许constexpr函数的返回值并非一个常量

constexpr函数不一定返回常量表达式

把内联函数和constexpr函数放在头文件内

它的多个定义必须完全一致。基于这个原因，内联函数和constexpr函数通常定义在头文件中。

ssert宏定义在cassert头文件中

预处理名字由预处理器而非编译器管理

如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行运行时检查。

#### 6.6 函数匹配

下一节将介绍“最匹配”的细节，它的基本思想是，实参类型与形参类型越接近，它们匹配得越好。

调用重载函数时应尽量避免强制类型转换。如果在实际应用中确实需要强制类型转换，则说明我们设计的形参集合不合理。

需要类型提升和算术类型转换的匹配

函数匹配和const实参

则当调用发生时编译器通过实参是否是常量来决定选择哪个函数

用非常量对象初始化常量引用需要类型转换，接受非常量形参的版本则与b精确匹配。因此，应该选用非常量版本的函数。

#### 6.7 函数指针

函数的类型由它的返回类型和形参类型共同决定，与函数名无关

> string&）。要想声明一个可以指向该函数的指针，只需要用指针替换函数名即可

==指针替换函数名==

＊pf两端的括号必不可少。如果不写这对括号，则pf是一个返回值为bool指针的函数：

当我们把函数名作为一个值使用时，该函数自动地转换成指针

此外，我们还能直接使用指向函数的指针调用该函数，无须提前解引用指针：

在指向不同函数类型的指针间不存在转换规则。但是和往常一样，我们可以为函数指针赋一个nullptr（参见2.3.2节，第48页）或者值为0的整型常量表达式，表示该指针没有指向任何一个函数：

编译器通过指针类型决定选用哪个函数，指针类型必须与重载函数中的某一个精确匹配

和数组类似（参见6.2.4节，第193页），虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。

我们可以直接把函数作为实参使用，此时它会自动转换成指针：

类型别名（参见2.5.1节，第60页）和decltype（参见2.5.3节，第62页）能让我们简化使用了函数指针的代码：

，decltype返回函数类型，此时不会将函数类型自动转换成指针类型。因为decltype的结果是函数类型，所以只有在结果前面加上＊才能得到指针

和数组类似（参见6.3.3节，第205页），虽然不能返回一个函数，但是能返回指向函数类型的指针。

声明getFcn唯一需要注意的地方是，牢记当我们将decltype作用于某个函数时，它返回函数类型而非指针类型。

### 第7章 类

封装实现了类的接口和实现的分离

#### 7.1 定义抽象数据类型

我们不能访问Sales_item对象的数据成员，事实上，我们甚至根本不知道这个类有哪些数据成员。

尽管所有成员都必须在类的内部声明，但是成员函数体可以定义在类内也可以定义在类外

因为this的目的总是指向“这个”对象，所以this是一个常量指针（参见2.4.2节，第56页），我们不允许改变this中保存的地址。

默认情况下，this的类型是指向类类型非常量版本的常量指针

const。尽管this是隐式的，但它仍然需要遵循初始化规则，意味着（在默认情况下）我们不能把this绑定到一个常量对象上（参见2.4.2节，第56页）。这一情况也就使得我们不能在一个常量对象上调用普通的成员函数。

紧跟在参数列表后面的const表示this是一个指向常量的指针。

常量对象，以及常量对象的引用或指针都只能调用常量成员函数。

因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。

在类的外部定义成员函数

定义一个返回this对象的函数

如前所述，我们无须使用隐式的this指针访问函数调用者的某个具体成员，而是需要把调用函数的对象当成一个整体来访问

如果函数在概念上属于类但是不定义在类中，则它一般应与类声明（而非定义）在同一个头文件内。在这种方式下，用户使用接口的任何部分都只需要引入一个文件。

一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内。

第一点，read和print分别接受一个各自IO类型的引用作为其参数，这是因为IO类属于不能被拷贝的类型，因此我们只能通过引用来传递它们（参见6.2.2节，第188页）。而且，因为读取和写入的操作会改变流的内容，所以两个函数接受的都是普通引用，而非对常量的引用。

print函数不负责换行。一般来说，执行输出任务的函数应该尽量减少对格式的控制，这样可以确保由用户代码来决定是否换行

#### 7.2 访问控制与封装

友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。

友元声明只能出现在类定义的内部

友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。

许多编译器并未强制限定友元函数必须在使用之前在类的外部声明。

#### 7.3 类的其他特性

需要指出的是，第二个构造函数（接受三个参数）为cursor成员隐式地使用了类内初始值（参见7.1.4节，第238页）。如果类中不存在cursor的类内初始值，我们就需要像其他成员一样显式地初始化cursor了。

令成员作为内联函数

可以在类的内部把inline作为声明的一部分显式地声明成员函数，同样的，也能在类的外部用inline关键字修饰函数的定义

不过，最好只在类外部定义的地方说明inline，这样可以使类更容易理解。

和我们在头文件中定义inline函数的原因一样（参见6.5.2节，第214页），inline成员函数也应该与相应的类定义在同一个头文件中。

重载成员函数

可变数据成员

。因此，一个const成员函数可以改变一个可变成员的值。

类数据成员的初始值

类内初始值必须使用=的初始化形式（初始化Screen的数据成员时所用的）或者花括号括起来的直接初始化形式（初始化screens所用的

当我们提供一个类内初始值时，必须以符号=或者花括号表示。

返回*this的成员函数

从const成员函数返回＊this

一个const成员函数如果以引用的形式返回＊this，那么它的返回类型将是常量引用。

当一个成员调用另外一个成员时，this指针在其中隐式地传递。

display的非常量版本调用do_display时，它的this指针将隐式地从指向非常量的指针转换成指向常量的指针

对于公共代码使用私有功能函数

我们很可能在开发过程中给do_display函数添加某些调试信息，而这些信息将在代码的最终产品版本中去掉。显然，只在do_display一处添加或删除这些信息要更容易一些。

这个额外的函数调用不会增加任何开销。因为我们在类内部定义了do_display，所以它隐式地被声明成内联函数。这样的话，调用do_display就不会带来任何额外的运行时开销。

可以定义指向这种类型的指针或引用，也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数。

> 一旦一个类的名字出现后，它就被认为是声明过了（但尚未定义），因此类允许包含指向它自身类型的引用或指针：

==比如链表==

友元函数能定义在类的内部，这样的函数是隐式内联的。

如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员

必须要注意的一点是，友元关系不存在传递性。也就是说，如果Window_mgr有它自己的友元，则这些友元并不能理所当然地具有访问Screen的特权。

每个类负责控制自己的友元类或友元函数。

如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明：

类和非成员函数的声明不是必须在它们的友元声明之前

即使我们仅仅是用声明友元的类的成员调用该友元函数，它也必须是被声明过的：

的作用是影响访问权限，它本身并非普通意义上的声明。

#### 7.4 类的作用域

函数的返回类型通常出现在函数名之前

编译器处理完类中的全部声明后才会处理成员函数的定义

用于类成员声明的名字查找

该函数的return语句返回名为bal的成员

类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后。

#### 7.5 构造函数再探

如果没有在构造函数的初始值列表中显式地初始化成员，则该成员将在构造函数体之前执行默认初始化

一区别到底会有什么深层次的影响完全依赖于数据成员的类型。

构造函数的初始值有时必不可少

有时我们可以忽略数据成员初始化和赋值之间的差异，但并非总能这样。如果成员是const或者是引用的话，必须将其初始化。类似的，当成员属于某种类类型且该类没有定义默认构造函数时，也必须将这个成员初始化

我们初始化const或者引用类型的数据成员的唯一机会就是通过构造函数初始值，因此该构造函数的正确形式应该是

如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初值

在很多类中，初始化和赋值的区别事关底层效率问题：前者直接初始化数据成员，后者则先初始化再赋值。
除了效率问题外更重要的是，一些数据成员必须被初始化。

成员的初始化顺序与它们在类定义中的出现顺序一致：第一个成员先被初始化，然后第二个，以此类推。构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。

一般来说，初始化的顺序没什么特别要求。不过如果一个成员是用另一个成员来初始化的，那么这两个成员的初始化顺序就很关键了。

最好令构造函数初始值的顺序与成员声明的顺序保持一致。而且如果可能的话，尽量避免使用某些成员初始化其他成员。

如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数

一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些（或者全部）职责委托给了其他构造函数。

和其他构造函数一样，一个委托构造函数也有一个成员初始值的列表和一个函数体

能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则。

只允许一步类类型转换

抑制构造函数定义的隐式转换

在要求隐式转换的程序上下文中，我们可以通过将构造函数声明为explicit加以阻止：

关键字explicit只对一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数指定为explicit的。

explicit构造函数只能用于直接初始化

当我们用explicit关键字声明构造函数时，它将只能以直接初始化的形式使用（参见3.2.1节，第76页）。而且，编译器将不会在自动转换过程中使用该构造函数。

为转换显式地使用构造函数

接受一个单参数的const char＊的string构造函数（参见3.2.1节，第76页）不是explicit的。

接受一个容量参数的vector构造函数（参见3.3.1节，第87页）是explicit的

聚合类（aggregate class）使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。当一个类满足如下条件时，我们说它是聚合的：

所有成员都是public的。· 没有定义任何构造函数。· 没有类内初始值（参见2.6.1节，第64页）。· 没有基类，也没有virtual函数

· 要求类的所有成员都是public的。· 将正确初始化每个对象的每个成员的重任交给了类的用户（而非类的作者）。因为用户很容易忘掉某个初始值，或者提供一个不恰当的初始值，所以这样的初始化过程冗长乏味且容易出错。· 添加或删除一个成员之后，所有的初始化语句都需要更新

constexpr函数的参数和返回值必须是字面值类型。

#### 7.6 类的静态成员

例如，一个银行账户类可能需要一个数据成员来表示当前的基准利率。

静态数据成员的类型可以是常量、引用、指针、类类型等

静态成员函数不能声明成const的

和其他的成员函数一样，我们既可以在类的内部也可以在类的外部定义静态成员函数。当在类的外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部的声明语句：

和类的所有成员一样，当我们指向类外部的静态成员时，必须指明成员所属的类名。static关键字则只出现在类内部的声明语句中。

相反的，必须在类的外部定义和初始化每个静态成员。和其他对象一样，一个静态数据成员只能定义一次

静态数据成员定义在任何函数之外。因此一旦它被定义，就将一直存在于程序的整个生命周期中

要想确保对象只定义一次，最好的办法是把静态数据成员的定义与其他非内联函数的定义放在同一个文件中

通常情况下，类的静态成员不应该在类的内部初始化。然而，我们可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr（参见7.5.6节，第267页）。初始值必须是常量表达式，

即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员

#### 8.1 IO类

[插图]
为了支持使用宽字符的语言，标准库定义了一组类型和对象来操纵wchar_t类型的数据（参见2.1.1节，第30页）。宽字符版本的类型和函数的名字以一个w开始。例如，wcin、wcout和wcerr是分别对应cin、cout和cerr的宽字符版对象。宽字符版本的类型和对象与其对应的普通char版本的类型定义在同一个头文件中。例如，头文件fstream定义了ifstream和wifstream类型。
IO类型间的关系
概念上，设备类型和字符大小都不会影响我们要执行的IO操作。例如，我们可以用>>读取数据，而不用管是从一个控制台窗口，一个磁盘文件，还是一个string读取。类似的，我们也不用管读取的字符能存入一个char对象内，还是需要一个wchar_t对象来存储。

本节剩下部分所介绍的标准库流特性都可以无差别地应用于普通流、文件流和string流，以及char或宽字符流版本。

IO对象无拷贝或赋值

IO库定义了4个iostate类型的constexpr值（参见2.4.4节，第58页），表示特定的位模式

管理输出缓冲

操作系统就可以将程序的多个输出操作组合成单一的系统级写操作。由于设备的写操作可能很耗时，允许操作系统将多个输出操作组合为单一的设备写操作可以带来很大的性能提升。

导致缓冲刷新

我们可以使用操纵符如endl（参见1.2节，第6页）来显式刷新缓冲区。

在每个输出操作之后，我们可以用操纵符unitbuf设置流的内部状态，来清空缓冲区。默认情况下，对cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新的。

如果程序崩溃，输出缓冲区不会被刷新


当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流

交互式系统通常应该关联输入流和输出流。这意味着所有输出，包括用户提示信息，都会在读操作之前被打印出来。

tie有两个重载的版本（参见6.4节，第206页）：一个版本不带参数，返回指向输出流的指针

tie的第二个版本接受一个指向ostream的指针，将自己关联到此ostream。即，x.tie（&o）将流x关联到输出流o。

#### 8.2 文件输入输出

 只可以对ofstream或fstream对象设定out模式。

只可以对ifstream或fstream对象设定in模式。

只有当out也被设定时才可设定trunc模式。

只要trunc没被设定，就可以设定app模式。在app模式下，即使没有显式指定out模式，文件也总是以输出方式被打开。

默认情况下，即使我们没有指定trunc，以out模式打开的文件也会被截断

ate和binary模式可用于任何类型的文件流对象，且可以与其他任何文件模式组合使用。

与ifstream关联的文件默认以in模式打开；与ofstream关联的文件默认以out模式打开；与fstream关联的文件默认以in和out模式打开。


#### 9.3 顺序容器操作

每个顺序容器都有一个front成员函数，而除forward_list之外的所有顺序容器都有一个back成员函数

#### 9.4 vector对象是如何增长的

这表明vector的实现采用的策略似乎是在每次需要分配新内存空间时将当前容量翻倍。

用shrink_to_fit只是一个请求，标准库并不保证退还内存。

每个vector实现都可以选择自己的内存分配策略。但是必须遵守的一条原则是：只有当迫不得已时才可以分配新的内存空间。

#### 9.5 额外的string操作

通常当我们从一个const char*创建string时，指针指向的数组必须以空字符结尾，拷贝操作遇到空字符时停止

> 给构造函数一个计数值，数组就不必以空字符结尾

==这时候，除了第一个参数，再传一个参数，数组就可采用以花括号初始化的形式==

> 编写程序，从一个vector<char>初始化一个string

==直接以容器构造的形式==

> 假定你希望每次读取一个字符存入一个string中，而且知道最少需要读取100个字符，应该如何提高程序的性能？

==原来是直接reserve(100)我还以为有更加好的办法==

此例中调用replace时，插入的文本恰好与删除的文本一样长。这不是必须的，可以插入一个更长或更短的string：

> 来自于一个字符指针（指向的字符数组）

==以空字符结尾
花括号包围的字符，不以空字符结尾==

> 编写一个函数，接受三个string参数s、oldVal和newVal。使用迭代器及insert和erase函数将s中所有oldVal替换为newVal。测试你的程序，用它替换通用的简写形式，如，将"tho"替换为"though"，将"thru"替换为"through"。

==void replaceOldwithNew(string& s, string& oldVal, string& newVal)
{
for (auto it = s.begin(), it!=s.end())
{
if(oldVal ==string(it, it+oldVa.size()))
{
it = s.erase(it, it+oldVla.size());
cur.insert(it, newVal.begin(),newVal.end());
it += newVal.size();
}
else{
it ++;
}
}
}==

compare函数

在这个stod调用中，我们调用了find_first_of（参见9.5.3节，第325页）来获得s中第一个可能是数值的一部分的字符的位置。我们将s中从此位置开始的子串传递给stod。

#### 9.6 容器适配器

队列适配器

标准库在元素类型上使用<运算符来确定相对优先级。

#### 小结

所有容器（除array外）都提供高效的动态内存管理

### 第10章 泛型算法

标准库并未给每个容器添加大量功能，而是提供了一组算法，这些算法中的大多数都独立于任何特定的容器

#### 10.1 概述

一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围（参见9.2.1节，第296页）来进行操作

此例中我们使用了标准库begin和end函数（参见3.5.3节，第106页）来获得指向ia中首元素和尾元素之后位置的指针，并传递给find。

虽然迭代器的使用令算法不依赖于容器类型，但大多数算法都使用了一个（或多个）元素类型上的操作

> 大多数算法提供了一种方法，允许我们使用自定义的操作来代替默认的运算符。

==怎么提供的==

算法永远不会执行容器的操作

算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素

#### 10.2 初识泛型算法

只读算法

accumulate的第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型。

将空串当做一个字符串字面值传递给第三个参数是不可以的，会导致一个编译错误。

如前所述，此类型决定了使用哪个+运算符。由于const char*并没有+运算符，此调用将产生编译错误。

equal基于一个非常重要的假设：它假定第二个序列至少与第一个序列一样长。此算法要处理第一个序列中的每个元素，它假定每个元素在第二个序列中都有一个与之对应的元素。

写容器元素的算法

对equal算法，元素类型不要求相同，但是我们必须能使用==来比较来自两个序列中的元素。

向目的位置迭代器写入数据的算法假定目的位置足够大，能容纳要写入的元素。

介绍back_inserter

back_inserter接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中：

在每步迭代中，fill_n向给定序列的一个元素赋值。由于我们传递的参数是back_inserter返回的迭代器，因此每次赋值都会在vec上调用push_back

拷贝算法

> 下面程序是否有错误？如果有，请改正

==要用插入迭代器：back_inserter
copy(lst.cbegin(), lst.cend(), back_inserter(vec));==

> 节提到过，标准库算法不会改变它们所操作的容器的大小。为什么使用back_inserter不会使这一断言失效？

==标准库算法根本不知道有“容器”这个东西。它们只接受迭代器参数，运行于这些迭代器之上，通过这些迭代器来访问元素==

由于算法不能执行容器的操作，我们将使用vector的erase成员来完成真正的删除操作

并返回一个指向不重复值范围末尾的迭代器

它只是覆盖相邻的重复元素，使得不重复元素出现在序列开始部分

此位置之后的元素仍然存在，但我们不知道它们的值是什么。

标准库算法对迭代器而不是容器进行操作。因此，算法不能（直接）添加或删除元素。

> 你认为算法不改变容器大小的原因是什么？

==一方面，改变容器大小可能会使得迭代器失效
另一方面，泛型算法在设计时就考虑了算法与数据分离，更加具有通用性==

#### 10.3 定制操作

向算法传递函数

版本是重载过的，它接受第三个参数，此参数是一个谓词（predicate）

接受谓词参数的算法对输入序列中的元素调用谓词。因此，元素类型必须能转换为谓词的参数类型

为了保持相同长度的单词按字典序排列，可以使用stable_sort算法。这种稳定排序算法维持相等元素的原有顺序。

标准库定义了名为partition的算法，它接受一个谓词，对容器内容进行划分，使得谓词为true的值会排在容器的前半部分，而使谓词为false的值会排在后半部分。算法返回一个迭代器，指向最后一个使谓词为true的元素之后的位置

lambda表达式

可调用对象（callable object

> 如果可以对其使用调用运算符（参见1.5.2节，第21页），则称它为可调用的。即，如果e是一个可调用的表达式，则我们可以编写代码e（args），其中args是一个逗号分隔的一个或多个参数的列表。

==重载函数调用算法：()==

> 到目前为止，我们使用过的仅有的两种可调用对象是函数和函数指针（参见6.7节，第221页）。还有其他两种可调用对象：重载了函数调用运算符的类，我们将在14.8节（第506页）介绍，以及lambda表达式（lambda expression）。

==4种可调用对象：函数、函数指针、重载了函数调用运算符的类(struct)、lambda expression==

一个lambda只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在函数体中使用该变量。

for_each算法

当定义一个lambda时，编译器生成一个与lambda对应的新的（未命名的）类类型。

当向一个函数传递一个lambda时，同时定义了一个新类型和该类型的一个对象

当使用auto定义一个用lambda初始化的变量时，定义了一个从lambda生成的类型的对象

值捕获

采用值捕获的前提是变量可以拷贝

与参数不同，被捕获的变量的值是在lambda创建时拷贝，而不是调用时拷贝

就必须确保被引用的对象在lambda执行的时候是存在的。lambda捕获的都是局部变量，这些变量在函数结束后就不复存在了。如果lambda可能在函数结束后执行，捕获的引用指向的局部变量已经消失。

引用捕获有时是必要的。

我们不能拷贝ostream对象（参见8.1.1节，第279页），因此捕获os的唯一方法就是捕获其引用（或指向os的指针）

**如果我们希望对一部分变量采用值捕获，对其他变量采用引用捕获，可以混合使用隐式捕获和显式捕获：**

改变一个被捕获的变量的值，就必须在参数列表首加上关键字mutable

> 默认情况下，如果一个lambda体包含return之外的任何语句，则编译器假定此lambda返回void

==要么只能有return一条语句
要么就不写return语句==

当我们需要为一个lambda定义返回类型时，必须使用尾置返回类型

参数绑定

我们可以解决向check_size传递一个长度参数的问题，方法是使用一个新的名为bind的标准库函数，它定义在头文件functional中。可以将bind函数看作一个通用的函数适配器（参见9.6节，第329页），它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。

> 此bind调用只有一个占位符，表示check6只接受单一参数。占位符出现在arg_list的第一个位置，表示check6的此参数对应check_size的第一个参数。此参数是一个const string&。因此，调用check6必须传递给它一个string类型的参数，check6会将此参数传递给check_size。

==占位符用来指代参数，而不是省略的意思==

名字_n都定义在一个名为placeholders的命名空间中，而这个命名空间本身定义在std命名空间（参见3.1节，第74页）中。为了使用这些名字，两个命名空间都要写上

即，第一个参数绑定到_1，第二个参数绑定到_2。因此，当我们调用g时，其第一个参数将被传递给f作为最后一个参数，第二个参数将被传递给f作为第三个参数。实际上，这个bind调用会将

对g的调用会调用f，用g的参数代替占位符，再加上绑定的参数a、b和c。例如，调用g（X，Y）会调用

#### 10.5 泛型算法结构

_if版本的算法

区分拷贝元素的版本和不拷贝的版本

### 第11章 关联容器

两个主要的关联容器（associative-container）类型是map和set

每个容器（1）或者是一个set，或者是一个map；（2）或者要求不重复的关键字，或者允许重复关键字；（3）按顺序保存元素，或无序保存。

#### 11.1 使用关联容器

map是关键字-值对的集合

关联数组（associative array

#### 11.2 关联容器概述

每个关联容器都定义了一个默认构造函数，它创建一个指定类型的空容器。我们也可以将关联容器初始化为另一个同类型容器的拷贝，或是从一个值范围来初始化关联容器，只要这些值可以转化为容器所需类型就可以

个map或set中的关键字必须是唯一的，即，对于一个给定的关键字，只能有一个元素的关键字等于它

容器multimap和multiset没有此限制，它们都允许多个元素具有相同的关键字

> 对于有序容器——map、multimap、set以及multiset，关键字类型必须定义元素比较的方法

==很重要，有序容器的关键字必须定义<==

默认情况下，标准库使用关键字类型的<运算符来比较两个关键字。

传递给排序算法的可调用对象（参见10.3.1节，第344页）必须满足与关联容器中关键字一样的类型要求。

> 提供的操作必须在关键字类型上定义一个严格弱序（strict weak ordering）。可以将严格弱序看作“小于等于”

==严格弱序=小于等于==

在实际编程中，重要的是，如果一个类型定义了“行为正常”的<运算符，则它可以用作关键字类型

函数在Sales_data对象的ISBN成员上定义了一个严格弱序。函数compareIsbn应该像下面这样定义

为了使用自己定义的操作，在定义multiset时我们必须提供两个类型：关键字类型Sales_data，以及比较操作类型——应该是一种函数指针类型

记住，当用decltype来获得一个函数指针类型时，必须加上一个*来指出我们要使用一个给定函数类型的指针

在介绍关联容器操作之前，我们需要了解名为pair的标准库类型，它定义在头文件utility中。

pair的默认构造函数对数据成员进行值初始化

用make_pair来生成pair对象，pair的两个类型来自于make_pair的参数：

#### 11.3 关联容器操作

对于set类型，key_type和value_type是一样的；set中保存的值就是关键字

由于我们不能改变一个元素的关键字，因此这些pair的关键字部分是const的：

例如，map<string，int>：：key_type

只有map类型（unordered_map、unordered_multimap、multimap和map）才定义了mapped_type。

set的迭代器是const的


关联容器的insert成员（见表11.4，第384页）向容器中添加一个元素或一个元素范围。由于map和set（以及对应的无序类型）包含不重复的关键字，因此插入一个已存在的元素对容器没有任何影响

insert有两个版本，分别接受一对迭代器，或是一个初始化器列表，

检测insert的返回值

如果关键字已在容器中，则insert什么事情也不做，且返回值中的bool部分为false。如果关键字不存在，元素被插入容器中，且bool值为true。


展开递增语句

关联容器定义了三个版本的erase，如表11.5所示。与顺序容器一样，我们可以通过传递给erase一个迭代器或一个迭代器对来删除一个元素或者一个元素范围。这两个版本的erase与对应的顺序容器的操作非常相似：指定的元素被删除，函数返回void

map的下标操作

如表11.6所示。set类型不支持下标，因为set中没有与关键字相关联的“值”。元素本身就是关键字，因此“获取与一个关键字相关联的值”的操作就没有意义了。

set类型不支持下标，因为set中没有与关键字相关联的“值”。元素本身就是关键字，因此“获取与一个关键字相关联的值”的操作就没有意义了。我们不能对一个multimap或一个unordered_multimap进行下标操作，因为这些容器中可能有多个值与一个关键字相关联。
类似我们用过的其他下标运算符，map下标运算符接受一个索引（即，一个关键字），获取与此关键字相关联的值。但是，与其他下标运算符不同的是，如果关键字并不在map中，会为它创建一个元素并插入到map中，关联值将进行值初始化（参见3.3.1节，第88页）。
例如，如果我们编写如下代码
[插图]
将会执行如下操作：

我们不能对一个multimap或一个unordered_multimap进行下标操作，因为这些容器中可能有多个值与一个关键字相关联。

map下标运算符接受一个索引（即，一个关键字），获取与此关键字相关联的值。但是，与其他下标运算符不同的是，如果关键字并不在map中，会为它创建一个元素并插入到map中，关联值将进行值初始化

使用下标操作的返回值

当对一个map进行下标操作时，会获得一个mapped_type对象；但当解引用一个map迭代器时，会得到一个value_type对象

与其他下标运算符相同的是，map的下标运算符返回一个左值（参见4.1.1节，第121页）。由于返回的是一个左值，所以我们既可以读也可以写元素

访问元素

对于不允许重复关键字的容器，可能使用find还是count没什么区别。但对于允许重复关键字的容器，count还会做更多的工作：如果元素在容器中，它还会统计有多少个元素有相同的关键字。如果不需要计数，最好使用find：

对map使用find代替下标操作

但有时，我们只是想知道一个给定关键字是否在map中，而不想改变map。这样就不能使用下标运算符来检查一个元素是否存在，因为如果关键字不存在的话，下标运算符会插入一个新元素。在这种情况下，应该使用find：

[插图]
首先调用count确定此作者共有多少本著作，并调用find获得一个迭代器，指向第一个关键字为此作者的元素。for循环的迭代次数依赖于count的返回值。特别是，如果count返回0，则循环一次也不执行。
[插图]
当我们遍历一个multimap或multiset时，保证可以得到序列中所有具有给定关键字的元素。
一种不同的，面向迭代器的解决方法
我们还可以用lower_bound和upper_bound来解决此问题。这两个操作都接受一个关键字，返回一个迭代器。如果关键字在容器中，lower_bound返回的迭代器将指向第一个具有给定关键字的元素，而upper_bound返回的迭代器则指向最后一个匹配给定关键字的元素之后的位置。

当我们遍历一个multimap或multiset时，保证可以得到序列中所有具有给定关键字的元素。

如果关键字在容器中，lower_bound返回的迭代器将指向第一个具有给定关键字的元素，而upper_bound返回的迭代器则指向最后一个匹配给定关键字的元素之后的位置

如果元素不在multimap中，则lower_bound和upper_bound会返回相等的迭代器——指向一个不影响排序的关键字插入位置。

使用这两个操作，我们可以重写前面的程序：

equal_range函数

直接调用equal_range即可。此函数接受一个关键字，返回一个迭代器pair。若关键字存在，则第一个迭代器指向第一个与关键字匹配的元素，第二个迭代器指向最后一个匹配元素之后的位置。若未找到匹配元素，则两个迭代器都指向关键字可以插入的位置。

#### 11.4 无序容器

这些容器不是使用比较运算符来组织元素，而是使用一个哈希函数（hash function）和关键字类型的==运算符

关键字类型的元素没有明显的序关系的情况下，无序容器是非常有用的。在某些应用中，维护元素的序代价非常高昂，此时无序容器也很有用。

无序容器在存储上组织为一组桶，每个桶保存零个或多个元素

无序容器使用一个哈希函数将元素映射到桶

为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶

如果容器允许重复关键字，所有具有相同关键字的元素也都会在同一个桶中

无序容器的性能依赖于哈希函数的质量和桶的数量和大小

理想情况下，哈希函数还能将每个特定的值映射到唯一的桶。但是，将不同关键字的元素映射到相同的桶也是允许的。当一个桶保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个。计算一个元素的哈希值和在桶中搜索通常都是很快的操作。但是，如果一个桶中保存了很多元素，那么查找一个特定元素就需要大量比较操作。

默认情况下，无序容器使用关键字类型的==运算符来比较元素，它们还使用一个hash<key_type>类型的对象来生成每个元素的哈希值

标准库为内置类型（包括指针）提供了hash模板。还为一些标准库类型，包括string和我们将要在第12章介绍的智能指针类型定义了hash。因此，我们可以直接定义关键字是内置类型（包括指针类型）、string还是智能指针类型的无序容器。

> 我们不能直接定义关键字类型为自定义类类型的无序容器。与容器不同，不能直接使用哈希模板，而必须提供我们自己的hash模板版本。

==只有提供了自定类型的hash模板才可以用无序容器==

我们不使用默认的hash，而是使用另一种方法，类似于为有序容器重载关键字类型的默认比较操作

我们需要提供函数来替代==运算符和哈希值计算函数

> 我们的hasher函数使用一个标准库hash类型对象来计算ISBN成员的哈希值，该hash类型建立在string类型之上。类似的，eqOp函数通过比较ISBN号来比较两个Sales_data。
我们使用这些函数来定义一个unordered_multiset

==如何定义自己的类型的hash和==,并以这两个函数定义u map==

如果我们的类定义了==运算符，则可以只重载哈希函数

### 第12章 动态内存

C++还支持动态分配对象。动态分配的对象的生存期与它们在哪里创建是无关的，只有当显式地被释放时，这些对象才会销毁

虽然使用动态内存有时是必要的，但众所周知，正确地管理动态内存是非常棘手的。

#### 12.1 动态内存与智能指针

在C++中，动态内存的管理是通过一对运算符来完成的：new，在动态内存中为对象分配空间并返回一个指向该对象的指针，我们可以选择对对象进行初始化；delete，接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。

shared_ptr允许多个指针指向同一个对象；unique_ptr则“独占”所指向的对象。标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。这三种类型都定义在memory头文件中。

到底是用一个计数器还是其他数据结构来记录有多少指针共享对象，完全由标准库的具体实现来决定。关键是智能指针类能记录有多少个shared_ptr指向相同的对象，并能在恰当的时候自动释放对象。

shared_ptr的析构函数会递减它所指向的对象的引用计数。如果引用计数变为0，shared_ptr的析构函数就会销毁对象，并释放它占用的内存。

你应该确保用erase删除那些不再需要的shared_ptr元素。

如果你将shared_ptr存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用erase删除不再需要的那些元素。

程序使用动态内存出于以下三种原因之一：1.程序不知道自己需要使用多少对象2.程序不知道所需对象的准确类型3.程序需要在多个对象间共享数据

自己直接管理内存的类与使用智能指针的类不同，它们不能依赖类对象拷贝、赋值和销毁操作的任何默认定义（参见7.1.4节，第237页）。因此，使用智能指针的程序更容易编写和调试。

用new分配const对象是合法的：

虽然一个const对象的值不能被改变，但它本身是可以被销毁的。如同任何其他动态对象一样，想要释放一个const动态对象，只要delete指向它的指针即可：

动态对象的生存期直到被释放时为止

返回指向动态内存的指针（而不是智能指针）的函数给其调用者增加了一个额外负担——调用者必须记得释放内存：

由内置指针（而不是智能指针）管理的动态内存在被显式释放前一直都会存在。

坚持只使用智能指针，就可以避免所有这些问题。对于一块内存，只有在没有任何智能指针指向它的情况下，智能指针才会自动释放它。

在delete之后，指针就变成了人们所说的空悬指针（dangling pointer），即，指向一块曾经保存数据对象但现在已经无效的内存的指针。

shared_ptr和new结合使用

出于相同的原因，一个返回shared_ptr的函数不能在其返回语句中隐式转换一个普通指针：

我们必须将shared_ptr显式绑定到一个想要返回的指针上：

使用一个内置指针来访问一个智能指针所负责的对象是很危险的，因为我们无法知道对象何时会被销毁。

get用来将指针的访问权限传递给代码，你只有在确定代码不会delete指针的情况下，才能使用get。特别是，永远不要用get初始化另一个智能指针或者为另一个智能指针赋值。

#### 12.2 动态数组

标准库中包含一个名为allocator的类，允许我们将分配和初始化分离

大多数应用应该使用标准库容器而不是动态分配的数组。使用容器更为简单、更不容易出现内存管理错误并且可能有更好的性能。

分配一个数组会得到一个元素类型的指针

由于分配的内存并不是一个数组类型，因此不能对动态数组调用begin或end（参见3.5.3节，第106页）。这些函数使用数组维度（回忆一下，维度是数组类型的一部分）来返回指向首元素和尾后元素的指针。出于相同的原因，也不能用范围for语句来处理（所谓的）动态数组中的元素。

allocator是一个模板

allocator分配的内存是未构造的（unconstructed）。我们按需要在此内存中构造对象。

### 第13章 拷贝控制

拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么。拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么

#### 13.1 拷贝、赋值与销毁

第一个参数必须是一个引用类型

对某些类来说，

合成拷贝构造函数（synthesized copy constructor）用来阻止我们拷贝该类类型的对象

一般情况，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中

拷贝初始化不仅在我们用=定义变量时会发生，在下列情况下也会发生· 将一个对象作为实参传递给一个非引用类型的形参· 从一个返回类型为非引用类型的函数返回一个对象· 用花括号列表初始化一个数组中的元素或一个聚合类中的成员（参见7.5.5节，第266页）

某些类类型还会对它们所分配的对象使用拷贝初始化

初始化标准库容器或是调用其insert或push成员（参见9.3.1节，第306页）时，容器会对其元素进行拷贝初始化。与之相对，用emplace成员创建的元素都进行直接初始化

拷贝构造函数被用来初始化非引用类类型参数

如果其参数不是引用类型，则调用永远也不会成功

为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数，如此无限循环

在拷贝初始化过程中，编译器可以（但不是必须）跳过拷贝/移动构造函数，直接创建对象。

> 拷贝构造函数是什么？什么时候使用它？

==如果一个构造函数的第一个参数是自身类类型的引用，且任何额外的参数都有默认值，则次构造函数是拷贝构造函数。==

重载运算符本质上是函数，其名字由operator关键字后接表示要定义的运算符的符号组成。因此，赋值运算符就是一个名为operator=的函数

某些运算符，包括赋值运算符，必须定义为成员函数

果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的this参数

一个指向其左侧运算对象的引用

标准库通常要求保存在容器中的类型要具有赋值运算符，且其返回值是左侧运算对象的引用

赋值运算符通常应该返回一个指向其左侧运算对象的引用。

> 对于某些类，合成拷贝赋值运算符用来禁止该类型对象的赋值（

===0？==

隐式销毁一个内置指针类型的成员不会delete它所指向的对象。

对于临时对象，当创建它的完整表达式结束时被销毁

当指向一个对象的引用或指针离开作用域时，析构函数不会执行。

当f返回时，hp和ret都被销毁，在两个对象上都会调用HasPtr的析构函数。此析构函数会delete ret和hp中的指针成员

构造函数。

需要拷贝操作的类也需要赋值操作，反之亦然

作为一个例子，考虑一个类为每个对象分配一个独有的、唯一的序号。这个类需要一个拷贝构造函数为每个新创建的对象生成一个新的、独一无二的序号。除此之外，这个拷贝构造函数从给定对象拷贝所有其他数据成员。这个类还需要自定义拷贝赋值运算符来避免将序号赋予目的对象。但是，这个类不需要自定义析构函数。

无论是需要拷贝构造函数还是需要拷贝赋值运算符都不必然意味着也需要析构函数。

在新标准下，我们可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数（deleted function）来阻止拷贝

析构函数不能是删除的成员

如果析构函数被删除，就无法销毁此类型的对象了。

对于析构函数已删除的类型，不能定义该类型的变量或释放指向该类型动态分配对象的指针。

private拷贝控制

声明但不定义一个成员函数是合法的（参见6.1.2节，第186页），对此只有一个例外，我们将在15.2.1节（第528页）中介绍。试图访问一个未定义的成员将导致一个链接时错误。

#### 13.2 拷贝控制和资源管理

拷贝（或赋值）一个shared_ptr会拷贝（赋值）shared_ptr所指向的指针。

#### 13.3 交换操作

> 我们首先将swap定义为friend，以便能访问HasPtr的（private的）数据成员。

==友员成员的使用例子==

例子中并不重要，但在一般情况下它非常重要——swap函数中调用的swap不是std：：swap

个swap调用应该都是未加限定的。即，每个调用都应该是swap，而不是std：：swap。如果存在类型特定的swap版本，其匹配程度会优于std中定义的版本

在赋值运算符中使用swap

这个技术的有趣之处是它自动处理了自赋值情况且天然就是异常安全的

改变左侧运算对象之前拷贝右侧运算对象保证了自赋值的正确

#### 13.4 拷贝控制示例

这种情况下，公共的工作应该放在private的工具函数中完成。

> Message类

==友元类的声明：
class Message{
    friend class Folder;
...}==

> 根据上述设计，我们可以编写Message类，如下所示

==C++ 中函数声明可以省略形参，只写形参类型==

#### 13.5 动态内存管理类

alloc_n_copy成员会分配足够的内存来保存给定范围的元素，并将这些元素拷贝到新分配的内存中。此函数返回一个指针的pair

#### 13.6 对象移动

最主要的特性是可以移动而非拷贝对象的能力

在其中某些情况下，对象拷贝后就立即被销毁了。在这些情况下，移动而非拷贝对象会大幅度提升性能

> 使用移动而不是拷贝的另一个原因源于IO类或unique_ptr这样的类。这些类都包含不能被共享的资源（如指针或IO缓冲）。因此，这些类型的对象不能拷贝但可以移动。

==使用移动的两个原因：
1 某些情况下，对象只是用来拷贝，拷贝完就销毁，此时使用移动会大幅提升性能
2 IO类或者unique_ptr类包含不能被共享的资源，这些类的对象不能拷贝，但是可以移动==

但在新标准中，我们可以用容器保存不可拷贝的类型，只要它们能被移动即可。

标准库容器、string和shared_ptr类既支持移动也支持拷贝。IO类和unique_ptr类可以移动但不能拷贝

为了支持移动操作，新标准引入了一种新的引用类型——右值引用

右值引用有一个重要的性质——只能绑定到一个将要销毁的对象。

类似任何引用，一个右值引用也不过是某个对象的另一个名字而已

常规引用（为了与右值引用区分开来，我们可以称之为左值引用（lvalue reference）

不能将其绑定到要求转换的表达式、字面常量或是返回右值的表达式

右值引用有着完全相反的绑定特性：我们可以将一个右值引用绑定到这类表达式上，但不能将一个右值引用直接绑定到一个左值上：

右值引用指向将要被销毁的对象。因此，我们可以从绑定到右值引用的对象“窃取”状态。

变量表达式都是左值。带来的结果就是，我们不能将一个右值引用绑定到一个右值引用类型的变量上，这有些令人惊讶

此函数定义在头文件utility中。move函数使用了我们将在16.2.6节（第610页）中描述的机制来返回给定对象的右值引用。

我们直接调用std：：move而不是move，其原因将在18.2.3节（第707页）中解释。

移后源对象必须可析构

如果一个类有一个可用的拷贝构造函数而没有移动构造函数，则其对象是通过拷贝构造函数来“移动”的。拷贝赋值运算符和移动赋值运算符的情况类似。

有五个拷贝控制成员应该看作一个整体：一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作

区分移动和拷贝的重载函数通常有一个版本接受一个const T&，而另一个版本接受一个T&&。

引用限定符可以是&或&&，分别指出this可以指向一个左值或右值。类似const限定符，引用限定符只能用于（非static）成员函数，且必须同时出现在函数的声明和定义中。

一个函数可以同时用const和引用限定。在此情况下，引用限定符必须跟随在const限定符之后：

#### 14.1 基本概念

它们的名字由关键字operator和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。

除了重载的函数调用运算符operator（）之外，其他重载运算符不能含有默认实参

当一个重载的运算符是成员函数时，this绑定到左侧运算对象。成员运算符函数的（显式）参数数量比运算对象的数量少一个。

#### 15.1 OOP：概述

此时基类就将这些函数声明成虚函数（virtual function）

派生类必须通过使用类派生列表（class derivation list）明确指出它是从哪个（哪些）基类继承而来的

C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，具体措施是在该函数的形参列表之后增加一个override关键字。

运行时绑定（run-time binding）。

在C++语言中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。

#### 15.2 定义基类和派生类

作为继承关系中根节点的类通常都会定义一个虚析构函数。

基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。

一种是基类希望其派生类进行覆盖的函数；另一种是基类希望派生类直接继承而不要改变的函数

关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义

在我们的继承层次关系中只有一个isbn函数，因此也就不存在调用isbn（）时到底执行哪个版本的疑问。

派生类必须将其继承而来的成员函数中需要覆盖的那些重新声明

访问说明符的作用是控制派生类从基类继承而来的成员是否对派生类的用户可见

这种转换通常称为派生类到基类的（derived-to-base）类型转换。和其他类型转换一样，编译器会隐式地执行派生类到基类的转换

在派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键所在。

每个类控制它自己的成员初始化过程。

派生类可以访问基类的公有成员和受保护成员：

静态成员遵循通用的访问控制规则，如果基类中的成员是private的，则派生类无权访问它。假设某静态成员是可访问的，则我们既能通过基类使用它也能通过派生类使用它

如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明

C++11新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字final

当使用基类的引用（或指针）时，实际上我们并不清楚该引用（或指针）所绑定对象的真实类型

和内置指针一样，智能指针类（参见12.1节，第400页）也支持派生类向基类的类型转换，这意味着我们可以将一个派生类对象的指针存储在一个基类的智能指针内

静态类型与动态类型

当我们使用存在继承关系的类型时，必须将一个变量或其他表达式的静态类型（static type）与该表达式表示对象的动态类型（dynamic type）区分开来

动态类型则是变量或表达式表示的内存中的对象的类型

如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致

基类的指针或引用的静态类型可能与其动态类型不一致，读者一定要理解其中的原因。

不存在从基类向派生类的隐式类型转换…

如果上述赋值是合法的，则我们有可能会使用bulkP或bulkRef访问base中本不存在的成员。

……在对象之间不存在类型转换

关键概念：存在继承关系的类型之间的转换规则

#### 16.1 定义模板

在模板定义中，模板参数列表不能为空。

编译器用推断出的模板参数来为我们实例化（instantiate）一个特定版本的函数。

模板类型参数

类型参数前必须使用关键字class或typename：

除了定义类型参数，还可以在模板中定义非类型参数（nontype parameter）。一个非类型参数表示一个值而非一个类型。

编译器会使用字面常量的大小来代替N和M，从而实例化模板。记住，编译器会在一个字符串字面常量的末尾插入一个空字符作为终结符（参见2.1.3节，第36页），因此编译器会实例化出如下版本：
[插图]
一个非类型参数可以是一个整型，或者是一个指向对象或函数类型的指针或（左值）引用。绑定到非类型整型参数的实参必须是一个常量表达式。绑定到指针或引用非类型参数的实参必须具有静态的生存期（参见第12章，第400页）。我们不能用一个普通（非static）局部变量或动态对象作为指针或引用非类型模板参数的实参。指针参数也可以用nullptr或一个值为0的常量表达式来实例化。
在模板定义内，模板非类型参数是一个常量值。在需要常量表达式的地方，可以使用非类型参数，例如，指定数组大小。

一个非类型参数可以是一个整型，或者是一个指向对象或函数类型的指针或（左值）引用

非类型模板参数的模板实参必须是常量表达式

函数模板可以声明为inline或constexpr的，如同非模板函数一样。inline或constexpr说明符放在模板参数列表之后，返回类型之前：

· 模板中的函数参数是const的引用。· 函数体中的条件判断仅使用<比较运算。

模板程序应该尽量减少对实参类型的要求。

因此，与非模板代码不同，模板的头文件通常既包括声明也包括定义。

函数模板和类模板成员函数的定义通常放在头文件中。

模板包含两种名字：· 那些不依赖于模板参数的名字· 那些依赖于模板参数的名字

模板的设计者应该提供一个头文件，包含模板定义以及在类模板或成员定义中用到的所有名字的声明

大多数编译错误在实例化期间报告

对于类模板，编译器可以检查用户是否提供了正确数目的模板实参

第三个阶段是模板实例化时，只有这个阶段才能发现类型相关的错误。依赖于编译器如何管理实例化，这类错误可能在链接时才报告。

当我们编写模板时，代码不能是针对特定类型的，但模板代码通常对其所使用的类型有一些假设

此实例化生成了一个无法编译通过的函数版本。但是，这样的错误直至编译器在类型Sales_data上实例化compare时才会被发现。

类模板（class template）是用来生成类的蓝图的。与函数模板的不同之处是，编译器不能为类模板推断模板参数类型

为了使用类模板，我们必须在模板名后的尖括号中提供额外信息

实例化类模板

我们现在知道这些额外信息是显式模板实参

一个类模板的每个实例都形成一个独立的类。类型Blob<string>与任何其他Blob类型都没有关联，也不会对任何其他Blob类型的成员有特殊访问权限。

在模板作用域中引用模板类型

一个类模板中的代码如果使用了另外一个模板，通常不将一个实际类型（或值）的名字用作其模板实参。

我们通常将模板自己的参数当作被使用模板的实参。

ta成员使用了两个模板，vector和shared_ptr。

类模板的成员函数

与其他任何类相同，我们既可以在类模板内部，也可以在类模板外部为其定义成员函数，且定义在类模板内的成员函数被隐式声明为内联函数。

类模板的成员函数本身是一个普通函数

类模板的每个实例都有其自己版本的成员函数

类模板的成员函数具有和模板相同的模板参数

定义在类模板之外的成员函数就必须以关键字template开始，后接类模板参数列表。

当我们在类外定义一个成员时，必须说明成员属于哪个类。

从一个模板生成的类的名字中必须包含其模板实参。

check和元素访问成员

它检查一个给定的索引

与其他任何定义在类模板外的成员一样，构造函数的定义要以模板参数开始

为了使用这个构造函数，我们必须传递给它一个initializer_list，其中的元素必须与Blob的元素类型兼容：

默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。

在类代码内简化模板类名的使用

当我们使用一个类模板类型时必须提供模板实参，但这一规则有一个例外。在类模板自己的作用域中，我们可以直接使用模板名而不提供实参：

BlobPtr的前置递增和递减成员返回BlobPtr&，而不是BlobPtr<T>&。当我们处于一个类模板的作用域中时，编译器处理模板自身引用时就好像我们已经提供了与模板参数匹配的实参一样

在类模板外使用类模板名

如果不提供模板实参，则编译器将假定我们使用的类型与成员实例化所用类型一致。

在一个类模板的作用域内，我们可以直接使用模板名而不必指定模板实参。

如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例

如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例

一对一友好关系

通用和特定的模板友好关系

一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元：

为了让所有实例成为友元，友元声明中必须使用与类模板本身不同的模板参数。

令模板自己的类型参数成为友元

在新标准中，我们可以将模板类型参数声明为友元

模板类型别名

无法定义一个typedef引用Blob<T>。

但是，新标准允许我们为类模板定义一个类型别名：

类模板的static成员

与任何其他类相同，类模板可以声明static成员

每个Foo的实例都有其自己的static成员实例

所有Foo<X>类型的对象共享相同的ctr对象和count函数

为了通过类来直接访问static成员，我们必须引用一个特定的实例

类似任何其他成员函数，一个static成员函数只有在使用时才会实例化。

模板参数遵循普通的作用域规则

一个模板参数名的可用范围是在其声明之后，至模板声明或定义结束之前

模板声明

使用类的类型成员

C++语言假定通过作用域运算符访问的名字不是类型

因此，如果我们希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是一个类型

当我们希望通知编译器一个名字表示类型时，必须使用关键字typename，而不能使用class。

我们也可以提供默认模板实参（default template argument）。在新标准中，我们可以为函数和类模板提供默认实参。而更早的C++标准只允许为类模板提供默认实参

与函数默认实参一样，对于一个模板参数，只有当它右侧的所有参数都有默认实参时，它才可以有默认实参。

且我们希望使用这些默认实参，就必须在模板名之后跟一个空尖括号对：

一个类（无论是普通类还是类模板）可以包含本身是模板的成员函数。这种成员被称为成员模板（member template）。成员模板不能是虚函数。

普通（非模板）类的成员模板

对于类模板，我们也可以为其定义成员模板。在此情况下，类和成员各自有自己的、独立的模板参数。

控制实例化

当模板被使用时才会进行实例化（参见16.1.1节，第582页）这一特性意味着，相同的实例可能出现在多个对象文件中

在新标准中，我们可以通过显式实例化（explicit instantiation）来避免这种开销

对每个实例化声明，在程序中某个位置必须有其显式的实例化定义。

shared_ptr和unique_ptr之间的明显不同是它们管理所保存的指针的策略——前者给予我们共享指针所有权的能力；后者则独占指针。这一差异对两个类的功能来说是至关重要的

#### 16.2 模板实参推断

我们已经看到，对于函数模板，编译器利用调用中的函数实参来确定其模板参数。从函数实参来确定模板实参的过程被称为模板实参推断

在模板实参推断过程中，编译器使用函数调用中的实参类型来寻找模板实参，用这些模板实参生成的函数版本与给定的函数调用最为匹配

onst转换：可以将一个非const对象的引用（或指针）传递给一个const的引用（或指针）形参（参见4.11.2节，第144页）。

数组或函数指针转换：如果函数形参不是引用类型，则可以对数组或函数类型的实参应用正常的指针转换。一个数组实参可以转换为一个指向其首元素的指针。类似的，一个函数实参可以转换为一个该函数类型的指针

其他类型转换，如算术转换（参见4.11.1节，第142页）、派生类向基类的转换（参见15.2.2节，第530页）以及用户定义的转换（参见7.5.4节，第263页和14.9节，第514页），都不能应用于函数模板。

将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有const转换及数组或函数到指针的转换。

使用相同模板参数类型的函数形参

正常类型转换应用于普通函数实参

函数模板可以有用普通类型定义的参数，即，不涉及模板类型参数的类型。

如果函数参数类型不是模板参数，则对实参进行正常的类型转换。

在某些情况下，编译器无法推断出模板实参的类型。其他一些情况下，我们希望允许用户控制模板实例化。当函数返回类型与参数列表中任何类型都不相同时，这两种情况最常出现。

指定显式模板实参

在本例中，没有任何函数实参的类型可用来推断T1的类型。每次调用sum时调用者都必须为T1提供一个显式模板实参（explicit template argument）。

正常类型转换应用于显式指定的实参

尾置返回类型与类型转换

在编译器遇到函数的参数列表之前，beg都是不存在的。为了定义此函数，我们必须使用尾置返回类型

进行类型转换的标准库模板类

为了获得元素类型，我们可以使用标准库的类型转换（type transformation）模板。这些模板定义在头文件type_traits中。这个头文件中的类通常用于所谓的模板元程序设计，这一主题已超出本书的范围。但是，类型转换模板在普通编程中也很有用。表16.1列出了这些模板，我们将在16.5节（第624页）中看到它们是如何实现的。

如果我们实例化remove_reference<int&>，则type成员将是int。类似的，如果我们实例化remove_reference<string&>，则type成员将是string，依此类推。更一般的，给定一个迭代器beg：

函数指针和实参推断

这段代码的问题在于，通过func的参数类型无法确定模板实参的唯一类型

我们可以通过使用显式模板实参来消除func调用的歧义：

模板实参推断和引用

其中函数参数p是一个模板类型参数T的引用，非常重要的是记住两点：编译器会应用正常的引用绑定规则；const是底层的，不是顶层的。

从左值引用函数参数推断类型

从右值引用函数参数推断类型

引用折叠和右值引用参数

在所有情况下（除了一个例外），引用会折叠成一个普通的左值引用类型。在新标准中，折叠规则扩展到右值引用。只在一种特殊情况下引用会折叠成右值引用：右值引用的右值引用。即，对于一个给定类型X：· X&&、X&&&和X&&&都折叠成类型X&· 类型X&&&&折叠成X&&

引用折叠只能应用于间接创建的引用的引用，如类型别名或模板参数。

函数参数是指向模板参数类型的右值引用

传递给它任意类型的实参

如果将一个左值传递给这样的参数，则函数参数被实例化为一个普通的左值引用（T&）。

std：：move是如何定义的

从一个左值static_cast到一个右值引用是允许的

转发

某些函数需要将其一个或多个实参连同类型不变地转发给其他函数

我们需要保持被转发实参的所有性质，包括实参类型是否是const的以及实参是左值还是右值

在调用中使用std：：forward保持类型信息

与std：：move相同，对std：：forward不使用using声明是一个好主意。我们将在18.2.3节（第706页）中解释原因。

#### 16.3 重载与模板

函数模板可以被另一个模板或一个普通非模板函数重载。与往常一样，名字相同的函数必须具有不同数量或类型的参数。

当有多个重载模板对一个调用提供同样好的匹配时，应选择最特例化的版本。

#### 16.4 可变参数模板

一个可变参数模板（variadic template）就是一个接受可变数目参数的模板函数或模板类。可变数目的参数被称为参数包（parameter packet）。存在两种参数包：模板参数包（template parameter packet），表示零个或多个模板参数；函数参数包（function parameter packet），表示零个或多个函数参数。

我们用一个省略号来指出一个模板参数或函数参数表示一个包。在一个模板参数列表中，class…或typename…指出接下来的参数表示零个或多个类型的列表；一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表。在函数参数列表中，如果一个参数的类型是一个模板参数包，则此参数也是一个函数参数包。例如：

sizeof…运算符

当我们需要知道包中有多少元素时，可以使用sizeof…运算符。类似sizeof（参见4.9节，第139页），sizeof…也返回一个常量表达式（参见2.4.4节，第58页），而且不会对其实参求值

如6.2.6节（第198页）所述，我们可以使用一个initializer_list来定义一个可接受可变数目实参的函数。但是，所有实参必须具有相同的类型（或它们的类型可以转换为同一个公共类型）

当我们既不知道想要处理的实参的数目也不知道它们的类型时，可变参数函数是很有用的

对于一个参数包，除了获取其大小外，我们能对它做的唯一的事情就是扩展（expand）它。当扩展一个包时，我们还要提供用于每个扩展元素的模式（pattern）

。我们通过在模式右边放一个省略号（…）来触发扩展操作

在新标准下，我们可以组合使用可变参数模板与forward机制来编写函数，实现将其实参不变地传递给其他函数

解释make_shared（参见12.1.1节，第401页）是如何工作的

#### 16.5 模板特例化

编写单一模板，使之对任何可能的模板实参都是最适合的，都能实例化，这并不总是能办到。

其他时候，我们也可以利用某些特定知识来编写更高效的代码，而不是从通用模板实例化。当我们不能（或不希望）使用模板版本时，可以定义类或函数模板的一个特例化版本。

为了处理字符指针（而不是数组），可以为第一个版本的compare定义一个模板特例化（template specialization）版本。一个特例化版本就是模板的一个独立的定义，在其中一个或多个模板参数被指定为特定的类型。

。为了指出我们正在实例化一个模板，应使用关键字template后跟一个空尖括号对（<>）。空尖括号指出我们将为原模板的所有模板参数提供实参

函数重载与模板特例化当定义函数模板的特例化版本时，我们本质上接管了编译器的工作。即，我们为原模板的一个特殊实例提供了定义。重要的是要弄清：一个特例化版本本质上是一个实例，而非函数名的一个重载版本。

特例化的本质是实例化一个模板，而非重载它。因此，特例化不影响函数匹配。

对此调用，两个函数模板都是可行的，且提供同样好的（即精确的）匹配。但是，接受字符数组参数的版本更特例化（参见16.3节，第615页），因此编译器会选择它。

但是，如果丢失了一个特例化版本的声明，编译器通常可以用原模板生成代码。由于在丢失特例化版本时编译器通常会实例化原模板，很容易产生模板及其特例化版本声明顺序导致的错误，而这种错误又很难查找。如果一个程序使用一个特例化版本，而同时原模板的一个实例具有相同的模板实参集合，就会产生错误。但是，这种错误编译器又无法发现。

模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明应该放在前面，然后是这些模板的特例化版本。

类模板特例化

在定义此特例化版本的hash时，唯一复杂的地方是：必须在原模板定义所在的命名空间中特例化它。

为了达到这一目的，首先必须打开命名空间：

，我们的hash函数计算所有三个数据成员的哈希值，从而与我们为Sales_data定义的operator==（参见14.3.1节，第497页）是兼容的

为了让Sales_data的用户能使用hash的特例化版本，我们应该在Sales_data的头文件中定义该特例化版本。

类模板部分特例化

我们只能部分特例化类模板，而不能部分特例化函数模板。

特例化成员而不是类

### 第Ⅳ部分 高级主题

这些特性分为两类：一类对于求解大规模的问题很有用；另一类适用于特殊问题而非通用问题。

bitset类和三个新标准库设施（tuple、正则表达式和随机数）

IO库中某些不常用的部分

运行时错误处理才显得更为重要也更难于管理

如果提供商不得不将他们定义的名字放置在单一的命名空间中，那么将多个独立开发的库组合起来是很困难的（

无论何时我们使用一个来自标准库的名字，实际上都是在使用名为std的命名空间中的名字。

多重继承。多重继承对非常复杂的继承层次很有用。

包括如何重定义内存分配机制

C++对运行时类型识别（run-time type identification，RTTI）的支持——允许我们在运行时才确定一个表达式的实际类型

以及如何定义和使用指向类成员的指针

成员指针还必须反映成员所属的类

聚合类型：联合、嵌套类和局部类。

本质上不可移植的语言特性：volatile修饰符、位域以及链接指令。

#### 17.1 tuple类型

tuple是类似pair（参见11.2.3节，第379页）的模板

我们可以将tuple看作一个“快速而随意”的数据结构

我们定义一个tuple时，需要指出每个成员的类型：

默认构造函数，它会对每个成员进行值初始化

tuple的这个构造函数是explicit的（参见7.5.4节，第265页），因此我们必须使用直接初始化语法

make_tuple函数，我们还可以用它来生成tuple对象：


make_tuple函数使用初始值的类型来推断tuple的类型

get的标准库函数模板

模板实参

我们传递给get一个tuple对象，它返回指定成员的引用

尖括号中的值必须是一个整型常量表达式

两个辅助类模板来查询tuple成员的数量和类型

tuple_size或tuple_element，我们需要知道一个tuple对象的类型

value的public static数据成员，

> 为了使用tuple的相等或不等运算符，对每对成员使用==运算符必须都是合法的；为了使用关系运算符，对每对成员使用<必须都是合法的。

==每对用来比较的对家必须定义了关示运并符或相等运算符 ．==

由于tuple定义了<和==运算符，我们可以将tuple序列传递给算法，并且可以在无序容器中将tuple作为关键字类型。

使用tuple返回多个值

equal_range的前两个实参是表示输入序列的迭代器（参见10.1节，第336页），第三个参数是一个值

因此我们传递给它一个指向compareIsbn函数的指针

equal_range算法返回一个迭代器pair

#### 17.2 bitset类型

bitset类，使得位运算的使用更为容易，并且能够处理超过最长整型类型大小的位集合

bitset的构造函数。bitset类是一个类模板

，它类似array类

具有固定的大小

大小必须是一个常量表达式

编号从0开始的二进制位被称为低位（low-order），编号到31结束的二进制位被称为高位（

用unsigned值初始化bitset

unsigned long long类型并被当作位模式来处理

如果bitset的大小大于一个unsigned long long中的二进制位数，则剩余的高位被置为0

从一个string初始化bitset


与往常一样，当我们使用字符串表示数时，字符串中下标最小的字符对应高位，

string的下标编号习惯与bitset恰好相反：string中下标最大的字符（最右字符）用来初始化bitset中的低位（下标为0的二进制位）。当你用一个string初始化一个bitset时，要记住这个差别。

我们不必使用整个string来作为bitset的初始值，可以只用一个子串作为初始值

to_ulong和to_ullong操作都返回一个值，保存了与bitset对象相同的位模式。只有当bitset的大小小于等于对应的大小（to_ulong为unsigned long，to_ullong为unsigned long long）时，我们才能使用这两个操作

如果bitset中的值不能放入给定类型中，则这两个操作会抛出一个overflow_error异常

#### 17.3 正则表达式

正则表达式（regular expression）是一种描述字符序列的方法，是一种极其强大的计算工具

#### 17.5 IO库再探

流随机访问

我们可以重定位流，使之跳过一些数据，首先读取最后一行，然后读取第一行，依此类推。

定位（seek）到流中给定的位置，以及告诉（tell）我们当前位置。

虽然标准库为所有流类型都定义了seek和tell函数，但它们是否会做有意义的事情依赖于流绑定到哪个设备

由于istream和ostream类型通常不支持随机访问，所以本节剩余内容只适用于fstream和sstream类型。

seek和tell函数

输入和输出版本的差别在于名字的后缀是g还是p。g版本表示我们正在“获得”（读取）数据，而p版本表示我们正在“放置”（写入）数据

由于只有单一的标记，因此只要我们在读写操作间切换，就必须进行seek操作来重定位标记。

#### 18.1 异常处理

在C++语言中，我们通过抛出（throwing）一条表达式来引发（raised）一个异常

当执行一个throw时，跟在throw后面的语句将不再被执行

程序的控制权从throw转移到与之匹配的catch模块

一个异常如果没有被捕获，则它将终止当前的程序。

catch子句（catch clause）中的异常声明（exception declaration）看起来像是只包含一个形参的函数形参列表。像在形参列表中一样，如果catch无须访问抛出的表达式的话，则我们可以忽略捕获形参的名字。

如果在多个catch语句的类型之间存在着继承关系，则我们应该把继承链最底端的类（most derived type）放在前面，而将继承链最顶端的类（least derived type）放在后面。

重新抛出

为了一次性捕获所有异常，我们使用省略号作为异常声明，这样的处理代码称为捕获所有异常（catch-all）的处理代码，形如catch（...）

处理构造函数初始值异常的唯一方法是将构造函数写成函数try语句块。

在C++11新标准中，我们可以通过提供noexcept说明（noexcept specification）指定某个函数不会抛出异常。其形式是关键字noexcept紧跟在函数的参数列表后面，用以标识该函数不会抛出异常：

noexcept说明符的实参常常与noexcept运算符（noexcept operator）混合使用。noexcept运算符是一个一元运算符，它的返回值是一个bool类型的右值常量表达式，用于表示给定的表达式是否会抛出异常。

#### 18.2 命名空间

多个库将名字放置在全局命名空间中将引发命名空间污染（namespace pollution）。

命名空间作用域后面无须分号

命名空间可以是不连续的

命名空间的一部分成员的作用是定义类，以及声明作为类接口的函数及对象，则这些成员应该置于头文件中，这些头文件将被包含在使用了这些成员的文件中

· 命名空间成员的定义部分则置于另外的源文件中。

定义多个类型不相关的命名空间应该使用单独的文件分别表示每个类型（或关联类型构成的集合）

定义命名空间成员

全局作用域中定义的名字（即在所有类、函数及命名空间之外定义的名字）也就是定义在全局命名空间（global namespace）中

内层命名空间声明的名字将隐藏外层命名空间声明的同名成员。在嵌套的命名空间中定义的名字只在内层命名空间中有效，外层命名空间中的代码要想访问它必须在名字前添加限定符。例如，在嵌套的命名空间QueryLib中声明的类名是

C++11新标准引入了一种新的嵌套命名空间，称为内联命名空间（inline namespace）。和普通的嵌套命名空间不同，内联命名空间中的名字可以被外层命名空间直接使用。也就是说，我们无须在内联命名空间的名字前添加表示该命名空间的前缀，通过外层命名空间的名字就可以直接访问它。定义内联命名空间的方式是在关键字namespace前添加关键字inline：

未命名的命名空间中定义的变量拥有静态生命周期：它们在第一次使用前创建，并且直到程序结束才销毁。

一个未命名的命名空间可以在某个给定的文件内不连续，但是不能跨越多个文件

和其他命名空间不同，未命名的命名空间仅在特定的文件内部有效，其作用范围不会横跨多个不同的文件。

在文件中进行静态声明的做法已经被C++标准取消了，现在的做法是使用未命名的命名空间。

一条using声明（using declaration）语句一次只引入命名空间的一个成员

避免using指示

#### 19.1 控制内存分配

第一步，new表达式调用一个名为operator new（或者operator new[]）的标准库函数

第二步，编译器运行相应的构造函数以构造这些对象，并为其传入初始值。第三步，对象被分配了空间并构造完成，返回一个指向该对象的指针。

。第一步，对sp所指的对象或者arr所指的数组中的元素执行对应的析构函数。第二步，编译器调用名为operator delete（或者operator delete[ ]）的标准库函数释放内存空间。

一条new表达式的执行过程总是先调用operator new函数以获取内存空间，然后在得到的内存空间中构造对象。与之相反，一条delete表达式的执行过程总是先销毁对象，然后调用operator delete函数释放对象所占的空间。

malloc函数与free函数

为此，我们可以使用名为malloc和free的函数，C++从C语言中继承了这些函数，并将其定义在cstdlib头文件中

malloc函数接受一个表示待分配字节数的size_t，返回指向分配空间的指针或者返回0以表示分配失败。free函数接受一个void＊，它是malloc返回的指针的副本，free将相关内存返回给系统。调用free（0）没有任何意义。

定位new表达式

尽管operator new函数和operator delete函数一般用于new表达式，然而它们毕竟是标准库的两个普通函数，因此普通的代码也可以直接调用它们。

与allocator不同的是，对于operator new分配的内存空间来说我们无法使用construct函数构造对象

当只传入一个指针类型的实参时，定位new表达式构造对象但是不分配内存。

在这里我们直接调用了一个析构函数。箭头运算符解引用指针sp以获得sp所指的对象，然后我们调用析构函数，析构函数的形式是波浪线（～）加上类型的名字

调用析构函数会销毁对象，但是不会释放内存。

#### 19.2 运行时类型识别

运行时类型识别

运行时类型识别（run-time type identification，RTTI）的功能由两个运算符实现：

typeid运算符，用于返回表达式的类型

 dynamic_cast运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用。

使用RTTI必须要加倍小心。在可能的情况下，最好定义虚函数而非直接接管类型管理的重任。

其中，type必须是一个类类型，并且通常情况下该类型应该含有虚函数。在第一种形式中，e必须是一个有效的指针（参见2.3.2节，第47页）；在第二种形式中，e必须是一个左值；在第三种形式中，e不能是左值。

e的类型是目标type的公有派生类、e的类型是目标type的公有基类或者e的类型就是目标type的类型

如果一条dynamic_cast语句的转换目标是指针类型并且失败了，则结果为

如果转换目标是引用类型并且失败了，则dynamic_cast运算符将抛出一个bad_cast异常。

我们可以对一个空指针执行dynamic_cast，结果是所需类型的空指针。值得注意的一点是，我们在条件部分定义了dp，这样做的好处是可以在一个操作中同时完成类型转换和条件检查两项任务。而且，指针dp在if语句外部是不可访问的。一旦转换失败，即使后续的代码忘了做相应判断，也不会接触到这个未绑定的指针，从而确保程序是安全的。

为RTTI提供的第二个运算符是typeid运算符（typeid operator），它允许程序向表达式提问：你的对象是什么类型？

typeid运算符可以作用于任意类型的表达式

如果表达式是一个引用，则typeid返回该引用所引对象的类型。不过当typeid作用于数组或函数时，并不会执行向指针的标准类型转换（参见4.11.2节，第143页）。也就是说，如果我们对数组a执行typeid（a），则所得的结果是数组类型而非指针类型。

当运算对象不属于类类型或者是一个不包含任何虚函数的类时，typeid运算符指示的是运算对象的静态类型

注意，typeid应该作用于对象，因此我们使用＊bp而非bp：

当typeid作用于指针时（而非指针所指的对象），返回的结果是该指针的静态编译时类型。

typeid是否需要运行时检查决定了表达式是否会被求值。只有当类型含有虚函数时，编译器才会对表达式求值

如果类型不含有虚函数，则typeid返回表达式的静态类型；编译器无须对表达式求值也能知道表达式的静态类型。

在某些情况下RTTI非常有用，比如当我们想为具有继承关系的类实现相等运算符时

#### 19.3 枚举类型

++11新标准引入了限定作用域的枚举类型（scoped enumeration）。定义限定作用域的枚举类型的一般形式是：首先是关键字enum class（或者等价地使用enum struct），随后是枚举类型名字以及用花括号括起来的以逗号分隔的枚举成员（enumerator）列表，最后是一个分号：

定义不限定作用域的枚举类型（unscoped enumeration）时省略掉关键字class（或struct），枚举类型的名字是可选的

与之相反，在不限定作用域的枚举类型中，枚举成员的作用域与枚举类型本身的作用域相同：

由枚举成员intTyp和shortTyp可知，枚举值不一定唯一。

和类一样，枚举也定义新的类型

枚举类型的前置声明

#### 19.4 类成员指针

成员指针（pointer to member）是指可以指向类的非静态成员的指针

成员指针的类型囊括了类的类型以及成员的类型

当初始化一个这样的指针时，我们令其指向类的某个成员，但是不指定该成员所属的对象；直到使用成员指针时，才提供成员所属的对象。

数据成员指针

与普通指针不同的是，成员指针还必须包含成员所属的类

我们必须在＊之前添加classname：：以表示当前定义的指针可以指向classname的成员

们将取地址运算符作用于Screen类的成员而非内存中的一个该类对象

读者必须清楚的一点是，当我们初始化一个成员指针或为成员指针赋值时，该指针并没有指向任何数据

成员指针指定了成员而非该成员所属的对象，只有当解引用成员指针时我们才提供对象的信息

和指向数据成员的指针一样，我们使用classname：：＊的形式声明一个指向成员函数的指针。

和普通的函数指针类似，如果成员存在重载的问题，则我们必须显式地声明函数类型以明确指出我们想要使用的是哪个函数

和普通函数指针不同的是，在成员函数和指向该成员的指针之间不存在自动转换规则：

#### 术语表

volatile 是一种类型限定符，告诉编译器变量可能在程序的直接控制之外发生改变。它起到一种标示的作用，令编译器不对代码进行优化操作。


### 我的想法
#### 11.2 关联容器概述

> 对于有序容器——map、multimap、set以及multiset，关键字类型必须定义元素比较的方法

==很重要，有序容器的关键字必须定义<==

> 提供的操作必须在关键字类型上定义一个严格弱序（strict weak ordering）。可以将严格弱序看作“小于等于”

==严格弱序=小于等于==

#### 11.4 无序容器

> 我们不能直接定义关键字类型为自定义类类型的无序容器。与容器不同，不能直接使用哈希模板，而必须提供我们自己的hash模板版本。

==只有提供了自定类型的hash模板才可以用无序容器==

> 我们的hasher函数使用一个标准库hash类型对象来计算ISBN成员的哈希值，该hash类型建立在string类型之上。类似的，eqOp函数通过比较ISBN号来比较两个Sales_data。
我们使用这些函数来定义一个unordered_multiset

==如何定义自己的类型的hash和==,并以这两个函数定义u map==

#### 13.1 拷贝、赋值与销毁

> 拷贝构造函数是什么？什么时候使用它？

==如果一个构造函数的第一个参数是自身类类型的引用，且任何额外的参数都有默认值，则次构造函数是拷贝构造函数。==

> 对于某些类，合成拷贝赋值运算符用来禁止该类型对象的赋值（

===0？==

#### 13.3 交换操作

> 我们首先将swap定义为friend，以便能访问HasPtr的（private的）数据成员。

==友员成员的使用例子==

#### 13.4 拷贝控制示例

> Message类

==友元类的声明：
class Message{
    friend class Folder;
...}==

> 根据上述设计，我们可以编写Message类，如下所示

==C++ 中函数声明可以省略形参，只写形参类型==

#### 13.6 对象移动

> 使用移动而不是拷贝的另一个原因源于IO类或unique_ptr这样的类。这些类都包含不能被共享的资源（如指针或IO缓冲）。因此，这些类型的对象不能拷贝但可以移动。

==使用移动的两个原因：
1 某些情况下，对象只是用来拷贝，拷贝完就销毁，此时使用移动会大幅提升性能
2 IO类或者unique_ptr类包含不能被共享的资源，这些类的对象不能拷贝，但是可以移动==

#### 17.1 tuple类型

> 为了使用tuple的相等或不等运算符，对每对成员使用==运算符必须都是合法的；为了使用关系运算符，对每对成员使用<必须都是合法的。

==每对用来比较的对家必须定义了关示运并符或相等运算符 ．==

#### 2.2 变量

> 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。

==初始化和赋值的区别:
创建时赋予一个初值
吧当前对象的值擦除，用新的值代替==

> 列表初始化

==花括号==

#### 2.3 复合类型

> 获取对象的地址指针存放某个对象的地址，要想获取该地址，需要使用取地址符（操作符&）：

==打印用%p==

> 获取对象的地址指针存放某个对象的地址，要想获取该地址，需要使用取地址符（操作符&）：

==想要打印某一个变量的地址，用取地址符&，取了之后可以直接赋给指针或者打印==

> 将要介绍的两种例外情况，其他所有指针的类型都要和它所指向的对象严格匹配：

==第一种：令指向常量的指针去指向一个非常量对象 *const==

> 因为在声明语句中指针的类型实际上被用于指定它所指向对象的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。

==这句话也就是为什么对指针这个对象进行解引用或者其他操作的时候，不会发生错误
指针本身也是一个对象(2.4.3第一句话)==

> 利用指针访问对象

==访问操作==

> 用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用：

==有点难==

> 要理解r的类型到底是什么，最简单的办法是从右向左阅读r的定义

==从右往左读类型！！！！！！！！！！！！！！！！！！==

#### 2.4 const限定符

> 正如之前反复提到的，对象的类型决定了其上的操作

==真的是反复提到，知道类型了才能进行操作==

#### 2.6 自定义数据结构

> 整个程序中的预处理变量包括头文件保护符必须唯一，通常的做法是基于头文件中类的名字来构建保护符的名字，以确保其唯一性。为了避免与程序中的其他实体发生名字冲突，一般把预处理变量的名字全部大写

==头文件保护==

#### 3.2 标准库类型string

> 例如，想要编写一个程序把0到15之间的十进制数转换成对应的十六进制形式，只需初始化一个字符串令其存放16个十六进制“数字”：

==十进制十六进制==

#### 3.4 迭代器介绍

> C++程序员习惯性地使用！=，其原因和他们更愿意使用迭代器而非下标的原因一样：因为这种编程风格在标准库提供的所有容器上都有效。

==很重要！不等号在所有容器上均生效==

#### 3.5 数组

> 所以就数组而言，由内向外阅读要比从右向左好多了。由内向外的顺序可帮助我们更好地理解Parray的含义：首先是圆括号括起来的部分，＊Parray意味着Parray是个指针，接下来观察右边，可知道Parray是个指向大小为10的数组的指针，最后观察左边，知道数组中的元素是int。这样最终的含义就明白无误了，Parray是一个指针，它指向一个int数组，数组中包含10个元素。同理，（&arrRef）表示arrRef是一个引用，它引用的对象是一个大小为10的数组，数组中元素的类型是int。

==明白数组怎么阅读==

> 在C++语言中，指针和数组有非常紧密的联系。就如即将介绍的，使用数组的时候编译器一般会把它转换成指针。

==使用数组时，编译器会把它转换成指针==

> 使用数组初始化vector对象

==很实用==

#### 6.1 函数基础

> 执行函数的第一步是（隐式地）定义并初始化它的形参

==但是非常不建议！！==

> 执行函数的第一步是（隐式地）定义并初始化它的形参

==只要有形参类型，而不需要有形参名字==

> 执行函数的第一步是（隐式地）定义并初始化它的形参

==函数申明其实可以不用写形参，函数定义时写上即可，不知道 在哪里看过==

#### 6.7 函数指针

> string&）。要想声明一个可以指向该函数的指针，只需要用指针替换函数名即可

==指针替换函数名==

#### 7.3 类的其他特性

> 一旦一个类的名字出现后，它就被认为是声明过了（但尚未定义），因此类允许包含指向它自身类型的引用或指针：

==比如链表==

#### 9.5 额外的string操作

> 给构造函数一个计数值，数组就不必以空字符结尾

==这时候，除了第一个参数，再传一个参数，数组就可采用以花括号初始化的形式==

> 编写程序，从一个vector<char>初始化一个string

==直接以容器构造的形式==

> 假定你希望每次读取一个字符存入一个string中，而且知道最少需要读取100个字符，应该如何提高程序的性能？

==原来是直接reserve(100)我还以为有更加好的办法==

> 来自于一个字符指针（指向的字符数组）

==以空字符结尾
花括号包围的字符，不以空字符结尾==

> 编写一个函数，接受三个string参数s、oldVal和newVal。使用迭代器及insert和erase函数将s中所有oldVal替换为newVal。测试你的程序，用它替换通用的简写形式，如，将"tho"替换为"though"，将"thru"替换为"through"。

==void replaceOldwithNew(string& s, string& oldVal, string& newVal)
{
for (auto it = s.begin(), it!=s.end())
{
if(oldVal ==string(it, it+oldVa.size()))
{
it = s.erase(it, it+oldVla.size());
cur.insert(it, newVal.begin(),newVal.end());
it += newVal.size();
}
else{
it ++;
}
}
}==

#### 10.1 概述

> 大多数算法提供了一种方法，允许我们使用自定义的操作来代替默认的运算符。

==怎么提供的==

#### 10.2 初识泛型算法

> 下面程序是否有错误？如果有，请改正

==要用插入迭代器：back_inserter
copy(lst.cbegin(), lst.cend(), back_inserter(vec));==

> 节提到过，标准库算法不会改变它们所操作的容器的大小。为什么使用back_inserter不会使这一断言失效？

==标准库算法根本不知道有“容器”这个东西。它们只接受迭代器参数，运行于这些迭代器之上，通过这些迭代器来访问元素==

> 你认为算法不改变容器大小的原因是什么？

==一方面，改变容器大小可能会使得迭代器失效
另一方面，泛型算法在设计时就考虑了算法与数据分离，更加具有通用性==

#### 10.3 定制操作

> 如果可以对其使用调用运算符（参见1.5.2节，第21页），则称它为可调用的。即，如果e是一个可调用的表达式，则我们可以编写代码e（args），其中args是一个逗号分隔的一个或多个参数的列表。

==重载函数调用算法：()==

> 到目前为止，我们使用过的仅有的两种可调用对象是函数和函数指针（参见6.7节，第221页）。还有其他两种可调用对象：重载了函数调用运算符的类，我们将在14.8节（第506页）介绍，以及lambda表达式（lambda expression）。

==4种可调用对象：函数、函数指针、重载了函数调用运算符的类(struct)、lambda expression==

> 默认情况下，如果一个lambda体包含return之外的任何语句，则编译器假定此lambda返回void

==要么只能有return一条语句
要么就不写return语句==

> 此bind调用只有一个占位符，表示check6只接受单一参数。占位符出现在arg_list的第一个位置，表示check6的此参数对应check_size的第一个参数。此参数是一个const string&。因此，调用check6必须传递给它一个string类型的参数，check6会将此参数传递给check_size。

==占位符用来指代参数，而不是省略的意思==

